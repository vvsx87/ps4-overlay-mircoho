diff -ruN a/arch/x86/include/asm/msi.h b/arch/x86/include/asm/msi.h
--- a/arch/x86/include/asm/msi.h	2022-10-13 07:15:22.225069815 +0200
+++ b/arch/x86/include/asm/msi.h	2022-10-13 06:48:56.624014506 +0200
@@ -11,4 +11,6 @@
 
 void pci_msi_set_desc(msi_alloc_info_t *arg, struct msi_desc *desc);
 
+void irq_msi_compose_msg(struct irq_data *data, struct msi_msg *msg);
+
 #endif /* _ASM_X86_MSI_H */
diff -ruN a/arch/x86/include/asm/ps4.h b/arch/x86/include/asm/ps4.h
--- a/arch/x86/include/asm/ps4.h	1970-01-01 01:00:00.000000000 +0100
+++ b/arch/x86/include/asm/ps4.h	2022-10-13 06:48:56.624014506 +0200
@@ -0,0 +1,60 @@
+/*
+ * ps4.h: Sony PS4 platform setup code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _ASM_X86_PS4_H
+#define _ASM_X86_PS4_H
+
+#ifdef CONFIG_X86_PS4
+
+#include <linux/irqdomain.h>
+
+#define PS4_DEFAULT_TSC_FREQ 1594000000
+
+#define EMC_TIMER_BASE 0xd0281000
+#define EMC_TIMER_VALUE 0x28
+
+extern unsigned long ps4_calibrate_tsc(void);
+
+/*
+ * The PS4 Aeolia southbridge device is a composite device containing some
+ * standard-ish, some not-so-standard, and some completely custom functions,
+ * all using special MSI handling. This function does the equivalent of
+ * pci_enable_msi_range and friends, for those devices. Only works after the
+ * Aeolia MSR routing function device (function 4) has been probed.
+ * Returns 1 or count, depending on IRQ allocation constraints, or negative on
+ * error. Assigned IRQ(s) start at dev->irq.
+ */
+extern int apcie_assign_irqs(struct pci_dev *dev, int nvec);
+extern void apcie_free_irqs(unsigned int virq, unsigned int nr_irqs);
+
+extern int apcie_status(void);
+extern int apcie_icc_cmd(u8 major, u16 minor, const void *data,
+			 u16 length, void *reply, u16 reply_length);
+
+
+#else
+
+static inline int apcie_assign_irqs(struct pci_dev *dev, int nvec)
+{
+	return -ENODEV;
+}
+static inline void apcie_free_irqs(unsigned int virq, unsigned int nvec)
+{
+}
+static inline int apcie_status(void)
+{
+	return -ENODEV;
+}
+static inline int apcie_icc_cmd(u8 major, u16 minor, const void *data,
+				u16 length, void *reply, u16 reply_length)
+{
+	return -ENODEV;
+}
+
+#endif
+#endif
diff -ruN a/arch/x86/include/asm/setup.h b/arch/x86/include/asm/setup.h
--- a/arch/x86/include/asm/setup.h	2022-10-13 07:15:22.226069840 +0200
+++ b/arch/x86/include/asm/setup.h	2022-10-13 06:48:56.624014506 +0200
@@ -59,6 +59,12 @@
 static inline void x86_ce4100_early_setup(void) { }
 #endif
 
+#ifdef CONFIG_X86_PS4
+extern void x86_ps4_early_setup(void);
+#else
+static inline void x86_ps4_early_setup(void) { }
+#endif
+
 #ifndef _SETUP
 
 #include <asm/espfix.h>
diff -ruN a/arch/x86/include/uapi/asm/bootparam.h b/arch/x86/include/uapi/asm/bootparam.h
--- a/arch/x86/include/uapi/asm/bootparam.h	2022-10-13 07:15:22.229069912 +0200
+++ b/arch/x86/include/uapi/asm/bootparam.h	2022-10-13 06:48:56.624014506 +0200
@@ -241,6 +241,7 @@
 	X86_SUBARCH_XEN,
 	X86_SUBARCH_INTEL_MID,
 	X86_SUBARCH_CE4100,
+	X86_SUBARCH_PS4,
 	X86_NR_SUBARCHS,
 };
 
diff -ruN a/arch/x86/Kconfig b/arch/x86/Kconfig
--- a/arch/x86/Kconfig	2022-10-13 07:15:22.213069523 +0200
+++ b/arch/x86/Kconfig	2022-10-13 06:48:56.625014531 +0200
@@ -514,6 +514,14 @@
 	  Adds support for Numascale NumaChip large-SMP systems. Needed to
 	  enable more than ~168 cores.
 	  If you don't have one of these, you should say N here.
+		
+config X86_PS4
+	bool "Sony PlayStation 4"
+	depends on X86_64
+	depends on X86_EXTENDED_PLATFORM
+	depends on PCI
+	---help---
+	  Select to include support for the Sony PlayStation 4 game console.
 
 config X86_VSMP
 	bool "ScaleMP vSMP"
diff -ruN a/arch/x86/kernel/apic/msi.c b/arch/x86/kernel/apic/msi.c
--- a/arch/x86/kernel/apic/msi.c	2022-10-13 07:15:22.241070204 +0200
+++ b/arch/x86/kernel/apic/msi.c	2022-10-13 06:48:56.626014557 +0200
@@ -48,7 +48,7 @@
 		MSI_DATA_VECTOR(cfg->vector);
 }
 
-static void irq_msi_compose_msg(struct irq_data *data, struct msi_msg *msg)
+void irq_msi_compose_msg(struct irq_data *data, struct msi_msg *msg)
 {
 	__irq_msi_compose_msg(irqd_cfg(data), msg);
 }
diff -ruN a/arch/x86/kernel/head64.c b/arch/x86/kernel/head64.c
--- a/arch/x86/kernel/head64.c	2022-10-13 07:15:22.238070131 +0200
+++ b/arch/x86/kernel/head64.c	2022-10-13 06:48:56.626014557 +0200
@@ -488,6 +488,11 @@
 	default:
 		break;
 	}
-
+	/* Call the subarch specific early setup function */
+	switch (boot_params.hdr.hardware_subarch) {
+	case X86_SUBARCH_PS4:
+		x86_ps4_early_setup();
+		break;
+	}
 	start_kernel();
 }
diff -ruN a/arch/x86/platform/Makefile b/arch/x86/platform/Makefile
--- a/arch/x86/platform/Makefile	2022-10-13 07:15:22.233070010 +0200
+++ b/arch/x86/platform/Makefile	2022-10-13 06:48:56.626014557 +0200
@@ -10,6 +10,7 @@
 obj-y	+= intel-mid/
 obj-y	+= intel-quark/
 obj-y	+= olpc/
+obj-y	+= ps4/
 obj-y	+= scx200/
 obj-y	+= sfi/
 obj-y	+= ts5500/
diff -ruN a/arch/x86/platform/ps4/calibrate.c b/arch/x86/platform/ps4/calibrate.c
--- a/arch/x86/platform/ps4/calibrate.c	1970-01-01 01:00:00.000000000 +0100
+++ b/arch/x86/platform/ps4/calibrate.c	2022-10-13 06:48:56.626014557 +0200
@@ -0,0 +1,116 @@
+/*
+ * calibrate.c: Sony PS4 TSC/LAPIC calibration
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+
+#define pr_fmt(fmt) "ps4: " fmt
+
+#include <linux/jiffies.h>
+#include <asm/io.h>
+#include <asm/msr.h>
+#include <asm/ps4.h>
+#include <asm/delay.h>
+#include <asm/apic.h>
+
+/* The PS4 southbridge (Aeolia) has an EMC timer that ticks at 32.768kHz,
+ * which seems to be an appropriate clock reference for calibration. Both TSC
+ * and the LAPIC timer are based on the core clock frequency and thus can be
+ * calibrated together. */
+static void __iomem *emc_timer = NULL;
+
+static __init inline u32 emctimer_read32(unsigned int reg)
+{
+	return ioread32(emc_timer + reg);
+}
+
+static __init inline void emctimer_write32(unsigned int reg, u32 val)
+{
+	iowrite32(val, emc_timer + reg);
+}
+
+static __init inline u32 emctimer_read(void)
+{
+	u32 t1, t2;
+	t1 = emctimer_read32(EMC_TIMER_VALUE);
+	while (1) {
+		t2 = emctimer_read32(EMC_TIMER_VALUE);
+		if (t1 == t2)
+			return t1;
+		t1 = t2;
+	}
+}
+
+static __init unsigned long ps4_measure_tsc_freq(void)
+{
+	unsigned long ret = 0;
+	u32 t1, t2;
+	u64 tsc1, tsc2;
+
+	// This is part of the Aeolia pcie device, but it's too early to
+	// do this in a driver.
+	emc_timer = ioremap(EMC_TIMER_BASE, 0x100);
+	if (!emc_timer)
+		goto fail;
+
+	// reset/start the timer
+	emctimer_write32(0x84, emctimer_read32(0x84) & (~0x01));
+	// udelay is not calibrated yet, so this is likely wildly off, but good
+	// enough to work.
+	udelay(300);
+	emctimer_write32(0x00, emctimer_read32(0x00) | 0x01);
+	emctimer_write32(0x84, emctimer_read32(0x84) | 0x01);
+
+	t1 = emctimer_read();
+	tsc1 = tsc2 = rdtsc();
+
+	while (emctimer_read() == t1) {
+		// 0.1s timeout should be enough
+		tsc2 = rdtsc();
+		if ((tsc2 - tsc1) > (PS4_DEFAULT_TSC_FREQ/10)) {
+			pr_warn("EMC timer is broken.\n");
+			goto fail;
+		}
+	}
+	pr_info("EMC timer started in %lld TSC ticks\n", tsc2 - tsc1);
+
+	// Wait for a tick boundary
+	t1 = emctimer_read();
+	while ((t2 = emctimer_read()) == t1);
+	tsc1 = rdtsc();
+
+	// Wait for 1024 ticks to elapse (31.25ms)
+	// We don't need to wait very long, as we are looking for transitions.
+	// At this value, a TSC uncertainty of ~50 ticks corresponds to 1ppm of
+	// clock accuracy.
+	while ((emctimer_read() - t2) < 1024);
+	tsc2 = rdtsc();
+
+	// TSC rate is 32 times the elapsed time
+	ret = (tsc2 - tsc1) * 32;
+
+	pr_info("Calibrated TSC frequency: %ld kHz\n", ret);
+fail:
+	if (emc_timer) {
+		iounmap(emc_timer);
+		emc_timer = NULL;
+	}
+	return ret;
+}
+
+unsigned long __init ps4_calibrate_tsc(void)
+{
+	unsigned long tsc_freq = ps4_measure_tsc_freq();
+
+	if (!tsc_freq) {
+		pr_warn("Unable to measure TSC frequency, assuming default.\n");
+		tsc_freq = PS4_DEFAULT_TSC_FREQ;
+	}
+
+	lapic_timer_frequency = (tsc_freq + 8 * HZ) / (16 * HZ);
+
+	return (tsc_freq + 500) / 1000;
+}
diff -ruN a/arch/x86/platform/ps4/Makefile b/arch/x86/platform/ps4/Makefile
--- a/arch/x86/platform/ps4/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/arch/x86/platform/ps4/Makefile	2022-10-13 06:48:56.627014582 +0200
@@ -0,0 +1 @@
+obj-$(CONFIG_X86_PS4) += ps4.o calibrate.o
diff -ruN a/arch/x86/platform/ps4/ps4.c b/arch/x86/platform/ps4/ps4.c
--- a/arch/x86/platform/ps4/ps4.c	1970-01-01 01:00:00.000000000 +0100
+++ b/arch/x86/platform/ps4/ps4.c	2022-10-13 06:48:56.627014582 +0200
@@ -0,0 +1,76 @@
+/*
+ * ps4.c: Sony PS4 platform setup code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+
+#define pr_fmt(fmt) "ps4: " fmt
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/scatterlist.h>
+#include <linux/sfi.h>
+#include <linux/irq.h>
+#include <linux/module.h>
+#include <linux/notifier.h>
+
+#include <asm/setup.h>
+#include <asm/mpspec_def.h>
+#include <asm/hw_irq.h>
+#include <asm/apic.h>
+#include <asm/io_apic.h>
+#include <asm/io.h>
+#include <asm/i8259.h>
+#include <asm/apb_timer.h>
+#include <asm/reboot.h>
+#include <asm/msr.h>
+#include <asm/ps4.h>
+
+static bool is_ps4;
+bool apcie_initialized;
+
+/*
+ * The RTC is part of the Aeolia PCI device and will be implemented there as
+ * an RTC class device; stub these out.
+ */
+static void dummy_get_wallclock(struct timespec64 *now)
+{
+	now->tv_sec = now->tv_nsec = 0;
+}
+static int dummy_set_wallclock(const struct timespec64 *now)
+{
+	return -ENODEV;
+}
+
+/*
+ * Provide a way for generic drivers to query for the availability of the
+ * PS4 apcie driver/device, which is a dependency for them.
+ */
+int apcie_status(void)
+{
+	if (!is_ps4)
+		return -ENODEV;
+	return apcie_initialized;
+}
+EXPORT_SYMBOL_GPL(apcie_status);
+
+void icc_reboot(void);
+
+/*
+ * PS4 specific x86_init function overrides and early setup calls.
+ */
+void __init x86_ps4_early_setup(void)
+{
+	pr_info("x86_ps4_early_setup: PS4 early setup\n");
+	is_ps4 = true;
+	x86_platform.calibrate_tsc = ps4_calibrate_tsc;
+	x86_platform.get_wallclock = dummy_get_wallclock;
+	x86_platform.set_wallclock = dummy_set_wallclock;
+
+	legacy_pic = &null_legacy_pic;
+	machine_ops.emergency_restart = icc_reboot;
+}
diff -ruN a/drivers/Makefile b/drivers/Makefile
--- a/drivers/Makefile	2022-10-13 07:15:21.141043467 +0200
+++ b/drivers/Makefile	2022-10-13 06:48:56.630014659 +0200
@@ -84,6 +84,7 @@
 obj-$(CONFIG_SPI)		+= spi/
 obj-$(CONFIG_SPMI)		+= spmi/
 obj-$(CONFIG_HSI)		+= hsi/
+obj-$(CONFIG_X86_PS4)		+= ps4/
 obj-$(CONFIG_SLIMBUS)		+= slimbus/
 obj-y				+= net/
 obj-$(CONFIG_ATM)		+= atm/
diff -ruN a/drivers/mmc/host/sdhci-pci-core.c b/drivers/mmc/host/sdhci-pci-core.c
--- a/drivers/mmc/host/sdhci-pci-core.c	2022-10-13 07:15:21.402049811 +0200
+++ b/drivers/mmc/host/sdhci-pci-core.c	2022-10-13 06:48:56.631014684 +0200
@@ -34,6 +34,10 @@
 
 #include "cqhci.h"
 
+#ifdef CONFIG_X86_PS4
+#include <asm/ps4.h>
+#endif
+
 #include "sdhci.h"
 #include "sdhci-pci.h"
 
@@ -311,6 +315,53 @@
 static const struct sdhci_pci_fixes sdhci_intel_qrk = {
 	.quirks		= SDHCI_QUIRK_NO_HISPD_BIT,
 };
+#ifdef CONFIG_X86_PS4
+static int aeolia_probe(struct sdhci_pci_chip *chip)
+{
+	chip->num_slots = 1;
+	chip->first_bar = 0;
+	if (apcie_status() == 0)
+		return -EPROBE_DEFER;
+
+	chip->pdev->class &= ~0x0000FF;
+	chip->pdev->class |= PCI_SDHCI_IFDMA;
+	return 0;
+}
+
+static int aeolia_probe_slot(struct sdhci_pci_slot *slot)
+{
+	int err = apcie_assign_irqs(slot->chip->pdev, 1);
+	if (err <= 0) {
+		dev_err(&slot->chip->pdev->dev, "failed to get IRQ: %d\n", err);
+		return -ENODEV;
+	}
+	slot->host->irq = slot->chip->pdev->irq;
+	return 0;
+}
+
+static void aeolia_remove_slot(struct sdhci_pci_slot *slot, int dead)
+{
+	apcie_free_irqs(slot->chip->pdev->irq, 1);
+}
+
+static int aeolia_enable_dma(struct sdhci_pci_slot *slot)
+{
+	if (pci_set_dma_mask(slot->chip->pdev, DMA_BIT_MASK(31))) {
+		return -EINVAL;
+	}
+	if (pci_set_consistent_dma_mask(slot->chip->pdev, DMA_BIT_MASK(31))) {
+		return -EINVAL;
+	}
+	return 0;
+}
+
+static const struct sdhci_pci_fixes sdhci_aeolia = {
+	.probe		= aeolia_probe,
+	.probe_slot	= aeolia_probe_slot,
+	.remove_slot	= aeolia_remove_slot,
+	.enable_dma	= aeolia_enable_dma,
+};
+#endif
 
 static int mrst_hc_probe_slot(struct sdhci_pci_slot *slot)
 {
@@ -1297,6 +1348,7 @@
 #endif
 };
 
+
 static const struct sdhci_pci_fixes sdhci_jmicron = {
 	.probe		= jmicron_probe,
 
@@ -1628,7 +1680,12 @@
 	SDHCI_PCI_DEVICE(O2, SDS1,     o2),
 	SDHCI_PCI_DEVICE(O2, SEABIRD0, o2),
 	SDHCI_PCI_DEVICE(O2, SEABIRD1, o2),
-	SDHCI_PCI_DEVICE(ARASAN, PHY_EMMC, arasan),
+	//SDHCI_PCI_DEVICE(ARASAN, PHY_EMMC, arasan),
+#ifdef CONFIG_X86_PS4
+	SDHCI_PCI_DEVICE(SONY, AEOLIA_SDHCI, aeolia),
+	SDHCI_PCI_DEVICE(SONY, BELIZE_SDHCI, aeolia),
+	//SDHCI_PCI_DEVICE(SONY, BAIKAL_SDHCI, aeolia),
+#endif
 	SDHCI_PCI_DEVICE(SYNOPSYS, DWC_MSHC, snps),
 	SDHCI_PCI_DEVICE_CLASS(AMD, SYSTEM_SDHCI, PCI_CLASS_MASK, amd),
 	/* Generic SD host controller */
@@ -1661,6 +1718,10 @@
 
 	pci_set_master(pdev);
 
+ 	if (slot->chip->fixes && slot->chip->fixes->enable_dma) {
+ 		return slot->chip->fixes->enable_dma(slot);
+ 	}
+
 	return 0;
 }
 
@@ -1775,12 +1836,13 @@
 \*****************************************************************************/
 
 static struct sdhci_pci_slot *sdhci_pci_probe_slot(
-	struct pci_dev *pdev, struct sdhci_pci_chip *chip, int first_bar,
+	struct pci_dev *pdev, struct sdhci_pci_chip *chip,
 	int slotno)
 {
 	struct sdhci_pci_slot *slot;
 	struct sdhci_host *host;
-	int ret, bar = first_bar + slotno;
+	int ret, bar = chip->first_bar + slotno;
+	//int ret, bar = first_bar + slotno;
 	size_t priv_size = chip->fixes ? chip->fixes->priv_size : 0;
 
 	if (!(pci_resource_flags(pdev, bar) & IORESOURCE_MEM)) {
@@ -2020,6 +2082,7 @@
 		chip->allow_runtime_pm = chip->fixes->allow_runtime_pm;
 	}
 	chip->num_slots = slots;
+	chip->first_bar = first_bar;
 	chip->pm_retune = true;
 	chip->rpm_retune = true;
 
@@ -2034,7 +2097,8 @@
 	slots = chip->num_slots;	/* Quirk may have changed this */
 
 	for (i = 0; i < slots; i++) {
-		slot = sdhci_pci_probe_slot(pdev, chip, first_bar, i);
+		slot = sdhci_pci_probe_slot(pdev, chip, i);
+		//slot = sdhci_pci_probe_slot(pdev, chip, first_bar, i);
 		if (IS_ERR(slot)) {
 			for (i--; i >= 0; i--)
 				sdhci_pci_remove_slot(chip->slots[i]);
diff -ruN a/drivers/mmc/host/sdhci-pci.h b/drivers/mmc/host/sdhci-pci.h
--- a/drivers/mmc/host/sdhci-pci.h	2022-10-13 07:15:21.403049836 +0200
+++ b/drivers/mmc/host/sdhci-pci.h	2022-10-13 06:48:56.631014684 +0200
@@ -128,7 +128,7 @@
 	int			(*probe_slot) (struct sdhci_pci_slot *);
 	int			(*add_host) (struct sdhci_pci_slot *);
 	void			(*remove_slot) (struct sdhci_pci_slot *, int);
-
+	int			(*enable_dma) (struct sdhci_pci_slot *);
 #ifdef CONFIG_PM_SLEEP
 	int			(*suspend) (struct sdhci_pci_chip *);
 	int			(*resume) (struct sdhci_pci_chip *);
@@ -169,6 +169,7 @@
 	const struct sdhci_pci_fixes *fixes;
 
 	int			num_slots;	/* Slots on controller */
+	int			first_bar;	/* First valid BAR */
 	struct sdhci_pci_slot	*slots[MAX_SLOTS]; /* Pointers to host slots */
 };
 
diff -ruN a/drivers/net/ethernet/marvell/sky2.c b/drivers/net/ethernet/marvell/sky2.c
--- a/drivers/net/ethernet/marvell/sky2.c	2022-10-13 07:15:21.608054818 +0200
+++ b/drivers/net/ethernet/marvell/sky2.c	2022-10-13 06:48:56.633014735 +0200
@@ -50,6 +50,11 @@
 
 #include <asm/irq.h>
 
+#ifdef CONFIG_X86_PS4
+#include <asm/ps4.h>
+#include "../../../ps4/aeolia.h"
+#endif
+
 #include "sky2.h"
 
 #define DRV_NAME		"sky2"
@@ -145,6 +150,9 @@
 	{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x4380) }, /* 88E8057 */
 	{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x4381) }, /* 88E8059 */
 	{ PCI_DEVICE(PCI_VENDOR_ID_MARVELL, 0x4382) }, /* 88E8079 */
+	{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_AEOLIA_GBE) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_BELIZE_GBE) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_BAIKAL_GBE) },
 	{ 0 }
 };
 
@@ -165,7 +173,7 @@
 
 	gma_write16(hw, port, GM_SMI_DATA, val);
 	gma_write16(hw, port, GM_SMI_CTRL,
-		    GM_SMI_CT_PHY_AD(PHY_ADDR_MARV) | GM_SMI_CT_REG_AD(reg));
+		    GM_SMI_CT_PHY_AD(hw->phy_addr) | GM_SMI_CT_REG_AD(reg));
 
 	for (i = 0; i < PHY_RETRIES; i++) {
 		u16 ctrl = gma_read16(hw, port, GM_SMI_CTRL);
@@ -190,8 +198,9 @@
 {
 	int i;
 
-	gma_write16(hw, port, GM_SMI_CTRL, GM_SMI_CT_PHY_AD(PHY_ADDR_MARV)
-		    | GM_SMI_CT_REG_AD(reg) | GM_SMI_CT_OP_RD);
+  gma_write16(hw, port, GM_SMI_CTRL, GM_SMI_CT_PHY_AD(hw->phy_addr)
+   		    | GM_SMI_CT_REG_AD(reg) | GM_SMI_CT_OP_RD);
+
 
 	for (i = 0; i < PHY_RETRIES; i++) {
 		u16 ctrl = gma_read16(hw, port, GM_SMI_CTRL);
@@ -1389,7 +1398,7 @@
 
 	switch (cmd) {
 	case SIOCGMIIPHY:
-		data->phy_id = PHY_ADDR_MARV;
+		data->phy_id = hw->phy_addr;
 
 		/* fallthru */
 	case SIOCGMIIREG: {
@@ -3249,7 +3258,23 @@
 	u16 status;
 	int i;
 	u32 hwe_mask = Y2_HWE_ALL_MASK;
-
+#ifdef CONFIG_X86_PS4
+	if (pdev->vendor == PCI_VENDOR_ID_SONY &&
+	    pdev->device == PCI_DEVICE_ID_SONY_AEOLIA_GBE) {
+		u32 val1, val2;
+
+		sky2_write32(hw, 0x60, 0x32100);
+		sky2_write32(hw, 0x64, 6);
+		sky2_write32(hw, 0x68, 0x63b9c);
+		sky2_write32(hw, 0x6c, 0x300);
+		val1 = sky2_read32(hw, 0x158);
+		val2 = sky2_read32(hw, 0x160);
+		val1 &= ~0x33333333;
+		val2 &= ~0xCC00000;
+		sky2_write32(hw, 0x158, val1);
+		sky2_write32(hw, 0x160, val2);
+	}
+#endif
 	/* disable ASF */
 	if (hw->chip_id == CHIP_ID_YUKON_EX
 	    || hw->chip_id == CHIP_ID_YUKON_SUPR) {
@@ -3313,7 +3338,12 @@
 		/* enable MACSec clock gating */
 		sky2_pci_write32(hw, PCI_DEV_REG3, P_CLK_MACSEC_DIS);
 	}
-
+#ifdef CONFIG_X86_PS4
+	if (pdev->vendor == PCI_VENDOR_ID_SONY &&
+	    pdev->device == PCI_DEVICE_ID_SONY_AEOLIA_GBE) {
+		; /* Do not perform phy resets on aeolia, it will hang */
+	} else
+  #endif
 	if (hw->chip_id == CHIP_ID_YUKON_OPT ||
 	    hw->chip_id == CHIP_ID_YUKON_PRM ||
 	    hw->chip_id == CHIP_ID_YUKON_OP_2) {
@@ -3598,7 +3628,7 @@
 	u32 supported, advertising;
 
 	supported = sky2_supported_modes(hw);
-	cmd->base.phy_address = PHY_ADDR_MARV;
+	cmd->base.phy_address = hw->phy_addr;
 	if (sky2_is_copper(hw)) {
 		cmd->base.port = PORT_TP;
 		cmd->base.speed = sky2->speed;
@@ -4744,7 +4774,43 @@
 	.ndo_get_stats64	= sky2_get_stats,
   },
 };
+#ifdef CONFIG_X86_PS4
+/* NOTE: This region is no longer referenced by current ps4 x86 code. */
+/* However it still contains the mac address. */
+static void aeolia_get_mac_address(struct sky2_hw *hw, unsigned char *addr) {
+	u8 default_addr[ETH_ALEN] = { 0x52, 0x54, 0x00, 0xf0, 0xff, 0x0f };
+	unsigned int mem_devfn = PCI_DEVFN(PCI_SLOT(hw->pdev->devfn), AEOLIA_FUNC_ID_MEM);
+	struct pci_dev *mem_dev;
+	phys_addr_t bp_base;
+	void __iomem *bp;
+
+	memcpy(addr, default_addr, sizeof(default_addr));
+
+	mem_dev = pci_get_slot(hw->pdev->bus, mem_devfn);
+	if (!mem_dev) {
+		dev_err(&hw->pdev->dev, "sky2: could not get handle to mem device\n");
+		return;
+	}
+
+	bp_base = pci_resource_start(mem_dev, 5) + APCIE_SPM_BP_BASE;
+	if (!request_mem_region(bp_base, APCIE_SPM_BP_SIZE, "spm.bp")) {
+		dev_err(&hw->pdev->dev, "sky2: failed to request bootparam SPM region\n");
+		return;
+	}
+
+	bp = ioremap(bp_base, APCIE_SPM_BP_SIZE);
+	if (!bp) {
+		dev_err(&hw->pdev->dev, "sky2: failed to map bootparam portion of SPM\n");
+		goto release_bp;
+	}
+
+	memcpy_fromio(addr, bp, ETH_ALEN);
 
+	iounmap(bp);
+release_bp:
+	release_mem_region(bp_base, APCIE_SPM_BP_SIZE);
+}
+#endif
 /* Initialize network device */
 static struct net_device *sky2_init_netdev(struct sky2_hw *hw, unsigned port,
 					   int highmem, int wol)
@@ -4816,7 +4882,12 @@
 		dev->max_mtu = ETH_DATA_LEN;
 	else
 		dev->max_mtu = ETH_JUMBO_MTU;
-
+#ifdef CONFIG_X86_PS4
+	if (hw->pdev->vendor == PCI_VENDOR_ID_SONY) {
+		aeolia_get_mac_address(hw, dev->dev_addr);
+	} else
+#endif
+  {
 	/* try to get mac address in the following order:
 	 * 1) from device tree data
 	 * 2) from internal registers set by bootloader
@@ -4827,7 +4898,7 @@
 	else
 		memcpy_fromio(dev->dev_addr, hw->regs + B2_MAC_1 + port * 8,
 			      ETH_ALEN);
-
+  }
 	/* if the address is invalid, use a random value */
 	if (!is_valid_ether_addr(dev->dev_addr)) {
 		struct sockaddr sa = { AF_UNSPEC };
@@ -4971,7 +5042,11 @@
 	int err, using_dac = 0, wol_default;
 	u32 reg;
 	char buf1[16];
-
+#ifdef CONFIG_X86_PS4
+	/* This will return negative on non-PS4 platforms */
+	if (apcie_status() == 0)
+		return -EPROBE_DEFER;
+#endif
 	err = pci_enable_device(pdev);
 	if (err) {
 		dev_err(&pdev->dev, "cannot enable PCI device\n");
@@ -5002,7 +5077,15 @@
 	}
 
 	pci_set_master(pdev);
-
+#ifdef CONFIG_X86_PS4
+	if (pdev->vendor == PCI_VENDOR_ID_SONY) {
+		if (pci_set_dma_mask(pdev, DMA_BIT_MASK(31)) < 0 ||
+		    pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(31)) < 0) {
+			dev_err(&pdev->dev, "no usable DMA configuration\n");
+			goto err_out_free_regions;
+		}
+	} else
+#endif
 	if (sizeof(dma_addr_t) > sizeof(u32) &&
 	    !(err = pci_set_dma_mask(pdev, DMA_BIT_MASK(64)))) {
 		using_dac = 1;
@@ -5050,7 +5133,15 @@
 		dev_err(&pdev->dev, "cannot map device registers\n");
 		goto err_out_free_hw;
 	}
-
+  hw->phy_addr = PHY_ADDR_MARV;
+#ifdef CONFIG_X86_PS4
+	if (pdev->vendor == PCI_VENDOR_ID_SONY &&
+	    pdev->device == PCI_DEVICE_ID_SONY_AEOLIA_GBE) {
+		/* aeolia supports some sort of "l2 switch" */
+		/* it has normal phy at addr 1 with a possibly-active switch at addr 2 */
+		hw->phy_addr = 1;
+	}
+#endif
 	err = sky2_init(hw);
 	if (err)
 		goto err_out_iounmap;
@@ -5075,6 +5166,19 @@
 		goto err_out_free_pci;
 	}
 
+#ifdef CONFIG_X86_PS4
+	if (pdev->vendor == PCI_VENDOR_ID_SONY &&
+	    apcie_assign_irqs(pdev, 1) > 0) {
+		err = sky2_test_msi(hw);
+		if (err) {
+			apcie_free_irqs(pdev->irq, 1);
+			/* PS4 requires MSI, so if it fails, bail out. */
+			goto err_out_free_netdev;
+		}
+		hw->flags |= SKY2_HW_USE_AEOLIA_MSI;
+	} else
+#endif
+
 	if (disable_msi == -1)
 		disable_msi = !!dmi_check_system(msi_blacklist);
 
@@ -5134,6 +5238,11 @@
 err_out_unregister:
 	unregister_netdev(dev);
 err_out_free_netdev:
+#ifdef CONFIG_X86_PS4
+	if (hw->flags & SKY2_HW_USE_AEOLIA_MSI)
+		apcie_free_irqs(pdev->irq, 1);
+	else
+#endif
 	if (hw->flags & SKY2_HW_USE_MSI)
 		pci_disable_msi(pdev);
 	free_netdev(dev);
@@ -5180,7 +5289,11 @@
 		napi_disable(&hw->napi);
 		free_irq(pdev->irq, hw);
 	}
-
+  #ifdef CONFIG_X86_PS4
+  	if (hw->flags & SKY2_HW_USE_AEOLIA_MSI)
+  		apcie_free_irqs(pdev->irq, 1);
+  	else
+  #endif
 	if (hw->flags & SKY2_HW_USE_MSI)
 		pci_disable_msi(pdev);
 	pci_free_consistent(pdev, hw->st_size * sizeof(struct sky2_status_le),
diff -ruN a/drivers/net/ethernet/marvell/sky2.h b/drivers/net/ethernet/marvell/sky2.h
--- a/drivers/net/ethernet/marvell/sky2.h	2022-10-13 07:15:21.608054818 +0200
+++ b/drivers/net/ethernet/marvell/sky2.h	2022-10-13 06:48:56.633014735 +0200
@@ -2294,7 +2294,7 @@
 #define SKY2_HW_VLAN_BROKEN     0x00000200
 #define SKY2_HW_RSS_CHKSUM	0x00000400	/* RSS requires chksum */
 #define SKY2_HW_IRQ_SETUP	0x00000800
-
+#define SKY2_HW_USE_AEOLIA_MSI	0x00001000
 	u8	     	     chip_id;
 	u8		     chip_rev;
 	u8		     pmd_type;
@@ -2308,7 +2308,7 @@
 	struct timer_list    watchdog_timer;
 	struct work_struct   restart_work;
 	wait_queue_head_t    msi_wait;
-
+	u8		     phy_addr;
 	char		     irq_name[0];
 };
 
diff -ruN a/drivers/pci/probe.c b/drivers/pci/probe.c
--- a/drivers/pci/probe.c	2022-10-13 07:15:21.233045703 +0200
+++ b/drivers/pci/probe.c	2022-10-13 06:48:56.633014735 +0200
@@ -2213,6 +2213,9 @@
 	pci_free_cap_save_buffers(dev);
 }
 
+// It can be arbitrary (above 2). Freebsd uses 20, so use that too.
+#define AEOLIA_SLOT_NUM 20
+
 /**
  * pci_release_dev - Free a PCI device structure when all users of it are
  *		     finished
@@ -2610,10 +2613,15 @@
 {
 	unsigned fn, nr = 0;
 	struct pci_dev *dev;
-
+	u32 l;
 	if (only_one_child(bus) && (devfn > 0))
 		return 0; /* Already scanned the entire slot */
-
+	// skip phantom Aeolia devices that bleed through the PCI space
+	if (PCI_SLOT(devfn) != AEOLIA_SLOT_NUM &&
+		pci_bus_read_dev_vendor_id(bus, devfn, &l, 60*1000) &&
+		(l & 0xffff) == PCI_VENDOR_ID_SONY) {
+		return 0;
+	}
 	dev = pci_scan_single_device(bus, devfn);
 	if (!dev)
 		return 0;
@@ -2621,6 +2629,11 @@
 		nr++;
 
 	for (fn = next_fn(bus, dev, 0); fn > 0; fn = next_fn(bus, dev, fn)) {
+		if (PCI_SLOT(devfn) != AEOLIA_SLOT_NUM &&
+			pci_bus_read_dev_vendor_id(bus, devfn + fn, &l, 60*1000) &&
+			(l & 0xffff) == PCI_VENDOR_ID_SONY) {
+			continue;
+		}
 		dev = pci_scan_single_device(bus, devfn + fn);
 		if (dev) {
 			if (!pci_dev_is_added(dev))
diff -ruN a/drivers/ps4/aeolia.h b/drivers/ps4/aeolia.h
--- a/drivers/ps4/aeolia.h	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/ps4/aeolia.h	2022-10-13 06:48:56.633014735 +0200
@@ -0,0 +1,172 @@
+#ifndef _AEOLIA_H
+#define _AEOLIA_H
+
+#include <linux/io.h>
+#include <linux/pci.h>
+#include <linux/i2c.h>
+
+enum aeolia_func_id {
+	AEOLIA_FUNC_ID_ACPI = 0,
+	AEOLIA_FUNC_ID_GBE,
+	AEOLIA_FUNC_ID_AHCI,
+	AEOLIA_FUNC_ID_SDHCI,
+	AEOLIA_FUNC_ID_PCIE,
+	AEOLIA_FUNC_ID_DMAC,
+	AEOLIA_FUNC_ID_MEM,
+	AEOLIA_FUNC_ID_XHCI,
+
+	AEOLIA_NUM_FUNCS
+};
+
+/* MSI registers for up to 31, but only 23 known. */
+#define APCIE_NUM_SUBFUNC		23
+
+/* Sub-functions, aka MSI vectors */
+enum apcie_subfunc {
+	APCIE_SUBFUNC_GLUE	= 0,
+	APCIE_SUBFUNC_ICC	= 3,
+	APCIE_SUBFUNC_HPET	= 5,
+	APCIE_SUBFUNC_SFLASH	= 11,
+	APCIE_SUBFUNC_RTC	= 13,
+	APCIE_SUBFUNC_UART0	= 19,
+	APCIE_SUBFUNC_UART1	= 20,
+	APCIE_SUBFUNC_TWSI	= 21,
+
+	APCIE_NUM_SUBFUNCS	= 23
+};
+
+#define APCIE_NR_UARTS 2
+
+/* Relative to BAR2 */
+#define APCIE_RGN_RTC_BASE		0x0
+#define APCIE_RGN_RTC_SIZE		0x1000
+
+#define APCIE_RGN_CHIPID_BASE		0x1000
+#define APCIE_RGN_CHIPID_SIZE		0x1000
+
+#define APCIE_REG_CHIPID_0		0x1104
+#define APCIE_REG_CHIPID_1		0x1108
+#define APCIE_REG_CHIPREV		0x110c
+
+/* Relative to BAR4 */
+#define APCIE_RGN_UART_BASE		0x140000
+#define APCIE_RGN_UART_SIZE		0x1000
+
+#define APCIE_RGN_PCIE_BASE		0x1c8000
+#define APCIE_RGN_PCIE_SIZE		0x1000
+
+#define APCIE_RGN_ICC_BASE		0x184000
+#define APCIE_RGN_ICC_SIZE		0x1000
+
+#define APCIE_REG_BAR(x)		(APCIE_RGN_PCIE_BASE + (x))
+#define APCIE_REG_BAR_MASK(func, bar)	APCIE_REG_BAR(((func) * 0x30) + \
+						((bar) << 3))
+#define APCIE_REG_BAR_ADDR(func, bar)	APCIE_REG_BAR(((func) * 0x30) + \
+						((bar) << 3) + 0x4)
+
+#define APCIE_REG_MSI(x)		(APCIE_RGN_PCIE_BASE + 0x400 + (x))
+#define APCIE_REG_MSI_CONTROL		APCIE_REG_MSI(0x0)
+#define APCIE_REG_MSI_MASK(func)	APCIE_REG_MSI(0x4c + ((func) << 2))
+#define APCIE_REG_MSI_DATA_HI(func)	APCIE_REG_MSI(0x8c + ((func) << 2))
+#define APCIE_REG_MSI_ADDR(func)	APCIE_REG_MSI(0xac + ((func) << 2))
+/* This register has non-uniform structure per function, dealt with in code */
+#define APCIE_REG_MSI_DATA_LO(off)	APCIE_REG_MSI(0x100 + (off))
+
+/* Not sure what the two individual bits do */
+#define APCIE_REG_MSI_CONTROL_ENABLE	0x05
+
+/* Enable for the entire function, 4 is special */
+#define APCIE_REG_MSI_MASK_FUNC		0x01000000
+#define APCIE_REG_MSI_MASK_FUNC4	0x80000000
+
+#define APCIE_REG_ICC(x)		(APCIE_RGN_ICC_BASE + (x))
+#define APCIE_REG_ICC_DOORBELL		APCIE_REG_ICC(0x804)
+#define APCIE_REG_ICC_STATUS		APCIE_REG_ICC(0x814)
+#define APCIE_REG_ICC_IRQ_MASK		APCIE_REG_ICC(0x824)
+
+/* Apply to both DOORBELL and STATUS */
+#define APCIE_ICC_SEND			0x01
+#define APCIE_ICC_ACK			0x02
+
+/* Relative to func6 BAR5 */
+#define APCIE_SPM_ICC_BASE		0x2c000
+#define APCIE_SPM_ICC_SIZE		0x1000
+
+/* Boot params passed from southbridge */
+#define APCIE_SPM_BP_BASE		0x2f000
+#define APCIE_SPM_BP_SIZE		0x20
+
+#define APCIE_SPM_ICC_REQUEST		0x0
+#define APCIE_SPM_ICC_REPLY		0x800
+
+#define ICC_REPLY 0x4000
+#define ICC_EVENT 0x8000
+
+#define ICC_MAGIC 0x42
+#define ICC_EVENT_MAGIC 0x24
+
+struct icc_message_hdr {
+	u8 magic;// not magic: it's ID of sender. 0x32=EAP,0x42=SoC(x86/fbsd)
+ 	u8 major;// service id (destination)
+ 	u16 minor;// message id (command)
+	u16 unknown;
+	u16 cookie; //normally monotonic xfer counter, can be set to special values
+	u16 length;
+	u16 checksum;
+} __packed;
+
+#define ICC_HDR_SIZE sizeof(struct icc_message_hdr)
+#define ICC_MIN_SIZE 0x20
+#define ICC_MAX_SIZE 0x7f0
+#define ICC_MIN_PAYLOAD (ICC_MIN_SIZE - ICC_HDR_SIZE)
+#define ICC_MAX_PAYLOAD (ICC_MAX_SIZE - ICC_HDR_SIZE)
+
+struct apcie_icc_dev {
+	phys_addr_t spm_base;
+	void __iomem *spm;
+
+	spinlock_t reply_lock;
+	bool reply_pending;
+
+	struct icc_message_hdr request;
+	struct icc_message_hdr reply;
+	u16 reply_extra_checksum;
+	void *reply_buffer;
+	int reply_length;
+	wait_queue_head_t wq;
+
+	struct i2c_adapter i2c;
+	struct input_dev *pwrbutton_dev;
+};
+
+struct apcie_dev {
+	struct pci_dev *pdev;
+	struct irq_domain *irqdomain;
+	void __iomem *bar0;
+	void __iomem *bar2;
+	void __iomem *bar4;
+
+	int nvec;
+	int serial_line[2];
+	struct apcie_icc_dev icc;
+};
+
+#define sc_err(...) dev_err(&sc->pdev->dev, __VA_ARGS__)
+#define sc_warn(...) dev_warn(&sc->pdev->dev, __VA_ARGS__)
+#define sc_notice(...) dev_notice(&sc->pdev->dev, __VA_ARGS__)
+#define sc_info(...) dev_info(&sc->pdev->dev, __VA_ARGS__)
+#define sc_dbg(...) dev_dbg(&sc->pdev->dev, __VA_ARGS__)
+
+static inline int apcie_irqnum(struct apcie_dev *sc, int index)
+{
+	if (sc->nvec > 1) {
+		return sc->pdev->irq + index;
+	} else {
+		return sc->pdev->irq;
+	}
+}
+
+int apcie_icc_cmd(u8 major, u16 minor, const void *data, u16 length,
+	    void *reply, u16 reply_length);
+
+#endif
diff -ruN a/drivers/ps4/icc/i2c.c b/drivers/ps4/icc/i2c.c
--- a/drivers/ps4/icc/i2c.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/ps4/icc/i2c.c	2022-10-13 06:48:56.633014735 +0200
@@ -0,0 +1,156 @@
+#include <linux/serial_8250.h>
+#include <linux/serial_core.h>
+#include <linux/serial_reg.h>
+
+#include "../aeolia.h"
+
+#define ICC_MAX_READ_DATA 0xff
+#define ICC_MAX_WRITE_DATA 0xf8
+
+/* This is actually multiple nested variable length structures, but since we
+ * currently only support one op per transaction, we hardcode it. */
+struct icc_i2c_msg {
+	/* Header */
+	u8 code;
+	u16 length;
+	u8 count;
+	struct {
+		u8 major;
+		u8 length;
+		u8 minor;
+		u8 count;
+		struct {
+			u8 length;
+			u8 slave_addr;
+			u8 reg_addr;
+			u8 data[ICC_MAX_WRITE_DATA];
+		} xfer;
+	} cmd;
+} __packed;
+
+static int icc_i2c_smbus_xfer(struct i2c_adapter *adapter, u16 addr,
+			  unsigned short flags,
+			  char read_write, u8 command, int size,
+			  union i2c_smbus_data *data)
+{
+	struct apcie_dev *sc = i2c_get_adapdata(adapter);
+	int ret;
+	struct icc_i2c_msg msg;
+	u8 resultbuf[8 + ICC_MAX_READ_DATA];
+
+	msg.code = 4; /* Don't really know what this is */
+	msg.count = 1;
+	msg.cmd.count = 1;
+	msg.cmd.xfer.slave_addr = addr << 1;
+	msg.cmd.xfer.reg_addr = command;
+	if (read_write == I2C_SMBUS_READ) {
+		msg.cmd.major = 1;
+		msg.cmd.minor = 1;
+		msg.cmd.length = 8;
+		msg.cmd.xfer.data[0] = 0; /* unknown */
+	} else {
+		msg.cmd.major = 2;
+		msg.cmd.minor = 2;
+	}
+
+	switch (size) {
+	case I2C_SMBUS_BYTE_DATA:
+		msg.cmd.xfer.length = 1;
+		if (read_write == I2C_SMBUS_WRITE) {
+			msg.cmd.length = 8;
+			msg.cmd.xfer.data[0] = data->byte;
+		}
+		break;
+	case I2C_SMBUS_WORD_DATA:
+		msg.cmd.xfer.length = 2;
+		if (read_write == I2C_SMBUS_WRITE) {
+			msg.cmd.length = 9;
+			msg.cmd.xfer.data[0] = data->word & 0xff;
+			msg.cmd.xfer.data[1] = data->word >> 8;
+		}
+		break;
+	case I2C_SMBUS_I2C_BLOCK_DATA:
+		msg.cmd.xfer.length = data->block[0];
+		if (read_write == I2C_SMBUS_WRITE) {
+			if (data->block[0] > ICC_MAX_WRITE_DATA) {
+				sc_err("icc-i2c: transaction too large: %d\n",
+				       data->block[0]);
+				return -E2BIG;
+			}
+			msg.cmd.length = 7 + data->block[0];
+			memcpy(msg.cmd.xfer.data, &data->block[1],
+			       data->block[0]);
+		}
+		break;
+	default:
+		sc_err("icc-i2c: unsupported transaction %d\n", size);
+		return -ENOTSUPP;
+	}
+
+	msg.length = msg.cmd.length + 4;
+	ret = apcie_icc_cmd(0x10, 0x0, &msg, msg.length, resultbuf,
+		      sizeof(resultbuf));
+	if (ret < 2 || ret > sizeof(resultbuf)) {
+		sc_err("icc-i2c: icc command failed: %d\n", ret);
+		return -EIO;
+	}
+	if (resultbuf[0] != 0 || resultbuf[1] != 0) {
+		sc_err("icc-i2c: i2c command failed: %d, %d\n",
+		       resultbuf[0], resultbuf[1]);
+		return -EIO;
+	}
+
+	if (read_write == I2C_SMBUS_READ)
+		switch (size) {
+		case I2C_SMBUS_BYTE_DATA:
+			data->byte = resultbuf[8];
+			break;
+		case I2C_SMBUS_WORD_DATA:
+			data->word = resultbuf[8] | (resultbuf[9] << 8);
+			break;
+		case I2C_SMBUS_I2C_BLOCK_DATA:
+			memcpy(&data->block[1], &resultbuf[8],
+			       data->block[0]);
+			break;
+		}
+
+	return 0;
+}
+
+u32 icc_i2c_functionality(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_SMBUS_BYTE_DATA |
+		I2C_FUNC_SMBUS_WORD_DATA |
+		I2C_FUNC_SMBUS_I2C_BLOCK;
+}
+
+static const struct i2c_algorithm icc_i2c_algo = {
+	.smbus_xfer   = &icc_i2c_smbus_xfer,
+	.functionality = &icc_i2c_functionality,
+};
+
+
+int icc_i2c_init(struct apcie_dev *sc)
+{
+	struct i2c_adapter *i2c;
+	int ret;
+
+	i2c = &sc->icc.i2c;
+	i2c->owner = THIS_MODULE;
+	i2c->algo = &icc_i2c_algo;
+	i2c->algo_data = NULL;
+	i2c->dev.parent = &sc->pdev->dev;
+	strlcpy(i2c->name, "icc", sizeof(i2c->name));
+	i2c_set_adapdata(i2c, sc);
+	ret = i2c_add_adapter(i2c);
+	if (ret < 0) {
+		sc_err("failed to add i2c adapter\n");
+		return ret;
+	}
+	return 0;
+}
+
+void icc_i2c_remove(struct apcie_dev *sc)
+{
+	i2c_del_adapter(&sc->icc.i2c);
+}
diff -ruN a/drivers/ps4/Makefile b/drivers/ps4/Makefile
--- a/drivers/ps4/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/ps4/Makefile	2022-10-13 06:48:56.633014735 +0200
@@ -0,0 +1,9 @@
+# Aeolia PCI devices
+# LISTED IN INIT ORDER \o/ ...  ._.
+# N.B. this driver must be init'd before pretty much everything, but actual dependants are:
+# drivers/net/ethernet/marvell/sky2 (implements ps4-gbe)
+obj-y += ps4-apcie.o \
+	ps4-apcie-uart.o \
+	ps4-apcie-icc.o \
+	ps4-apcie-pwrbutton.o \
+	icc/i2c.o \
diff -ruN a/drivers/ps4/ps4-apcie.c b/drivers/ps4/ps4-apcie.c
--- a/drivers/ps4/ps4-apcie.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/ps4/ps4-apcie.c	2022-10-13 06:48:56.634014761 +0200
@@ -0,0 +1,534 @@
+#define DEBUG
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/irqchip.h>
+#include <linux/irqdomain.h>
+#include <linux/msi.h>
+#include <asm/irqdomain.h>
+#include <asm/irq_remapping.h>
+
+#include <asm/msi.h>
+
+#include <asm/ps4.h>
+
+#include "aeolia.h"
+
+/* #define QEMU_HACK_NO_IOMMU */
+
+/* Number of implemented MSI registers per function */
+static const int subfuncs_per_func[AEOLIA_NUM_FUNCS] = {
+	4, 4, 4, 4, 31, 2, 2, 4
+};
+
+static inline u32 glue_read32(struct apcie_dev *sc, u32 offset) {
+	return ioread32(sc->bar4 + offset);
+}
+
+static inline void glue_write32(struct apcie_dev *sc, u32 offset, u32 value) {
+	iowrite32(value, sc->bar4 + offset);
+}
+
+static inline void glue_set_region(struct apcie_dev *sc, u32 func, u32 bar,
+			    u32 base, u32 mask) {
+	glue_write32(sc, APCIE_REG_BAR_MASK(func, bar), mask);
+	glue_write32(sc, APCIE_REG_BAR_ADDR(func, bar), base);
+}
+
+static inline void glue_set_mask(struct apcie_dev *sc, u32 offset, u32 mask) {
+	void __iomem *ptr = sc->bar4 + offset;
+	iowrite32(ioread32(ptr) | mask, ptr);
+}
+
+static inline void glue_clear_mask(struct apcie_dev *sc, u32 offset, u32 mask) {
+	void __iomem *ptr = sc->bar4 + offset;
+	iowrite32(ioread32(ptr) & ~mask, ptr);
+}
+
+static inline void glue_mask_and_set(struct apcie_dev *sc, u32 offset, u32 mask, u32 set) {
+	void __iomem *ptr = sc->bar4 + offset;
+	iowrite32((ioread32(ptr) & ~mask) | set, ptr);
+}
+
+static void apcie_config_msi(struct apcie_dev *sc, u32 func, u32 subfunc,
+			     u32 addr, u32 data) {
+	u32 offset;
+
+	sc_dbg("apcie_config_msi: func: %u, subfunc: %u, addr %08x data: 0x%08x (%u)\n",
+		func, subfunc, addr, data, data);
+
+	glue_clear_mask(sc, APCIE_REG_MSI_CONTROL, APCIE_REG_MSI_CONTROL_ENABLE);
+	/* Unknown */
+	glue_write32(sc, APCIE_REG_MSI(0x8), 0xffffffff);
+	/* Unknown */
+	glue_write32(sc, APCIE_REG_MSI(0xc + (func << 2)), 0xB7FFFF00 + func * 16);
+	glue_write32(sc, APCIE_REG_MSI_ADDR(func), addr);
+	/* Unknown */
+	glue_write32(sc, APCIE_REG_MSI(0xcc + (func << 2)), 0);
+	glue_write32(sc, APCIE_REG_MSI_DATA_HI(func), data & 0xffe0);
+
+	if (func < 4) {
+		/* First 4 functions have 4 IRQs/subfuncs each */
+		offset = (func << 4) | (subfunc << 2);
+	} else if (func == 4) {
+		/* Function 4 gets 24 consecutive slots,
+		 * then 7 more at the end. */
+		if (subfunc < 24)
+			offset = 0x40 + (subfunc << 2);
+		else
+			offset = 0xe0 + ((subfunc - 24) << 2);
+	} else {
+		offset = 0xa0 + ((func - 5) << 4) + (subfunc << 2);
+	}
+	glue_write32(sc, APCIE_REG_MSI_DATA_LO(offset), data & 0x1f);
+
+	if (func == AEOLIA_FUNC_ID_PCIE)
+		glue_set_mask(sc, APCIE_REG_MSI_MASK(func), APCIE_REG_MSI_MASK_FUNC4);
+	else
+		glue_set_mask(sc, APCIE_REG_MSI_MASK(func), APCIE_REG_MSI_MASK_FUNC);
+
+	glue_set_mask(sc, APCIE_REG_MSI_CONTROL, APCIE_REG_MSI_CONTROL_ENABLE);
+}
+
+static void apcie_msi_write_msg(struct irq_data *data, struct msi_msg *msg)
+{
+	struct apcie_dev *sc = data->chip_data;
+	u32 func = data->hwirq >> 8;
+	u32 subfunc = data->hwirq & 0xff;
+
+	/* Linux likes to unconfigure MSIs like this, but since we share the
+	 * address between subfunctions, we can't do that. The IRQ should be
+	 * masked via apcie_msi_mask anyway, so just do nothing. */
+	if (!msg->address_lo) {
+		return;
+	}
+
+	sc_dbg("apcie_msi_write_msg(%08x, %08x) mask=0x%x irq=%d hwirq=0x%lx %p\n",
+	       msg->address_lo, msg->data, data->mask, data->irq, data->hwirq, sc);
+
+	if (subfunc == 0xff) {
+		int i;
+		for (i = 0; i < subfuncs_per_func[func]; i++)
+			apcie_config_msi(sc, func, i, msg->address_lo, msg->data);
+	} else {
+		apcie_config_msi(sc, func, subfunc, msg->address_lo, msg->data);
+	}
+}
+
+static void apcie_msi_unmask(struct irq_data *data)
+{
+	struct apcie_dev *sc = data->chip_data;
+	u32 func = data->hwirq >> 8;
+
+	glue_set_mask(sc, APCIE_REG_MSI_MASK(func), data->mask);
+}
+
+static void apcie_msi_mask(struct irq_data *data)
+{
+	struct apcie_dev *sc = data->chip_data;
+	u32 func = data->hwirq >> 8;
+
+	glue_clear_mask(sc, APCIE_REG_MSI_MASK(func), data->mask);
+}
+
+static void apcie_msi_calc_mask(struct irq_data *data) {
+	u32 func = data->hwirq >> 8;
+	u32 subfunc = data->hwirq & 0xff;
+
+	if (subfunc == 0xff) {
+		data->mask = (1 << subfuncs_per_func[func]) - 1;
+	} else {
+		data->mask = 1 << subfunc;
+	}
+}
+
+static struct irq_chip apcie_msi_controller = {
+	.name = "Aeolia-MSI",
+	.irq_unmask = apcie_msi_unmask,
+	.irq_mask = apcie_msi_mask,
+	.irq_ack = irq_chip_ack_parent,
+	.irq_set_affinity = msi_domain_set_affinity,
+	.irq_retrigger = irq_chip_retrigger_hierarchy,
+	.irq_compose_msi_msg = irq_msi_compose_msg,
+	.irq_write_msi_msg = apcie_msi_write_msg,
+	.flags = IRQCHIP_SKIP_SET_WAKE,
+};
+
+static irq_hw_number_t apcie_msi_get_hwirq(struct msi_domain_info *info,
+					  msi_alloc_info_t *arg)
+{
+	return arg->msi_hwirq;
+}
+
+static int apcie_msi_init(struct irq_domain *domain,
+			 struct msi_domain_info *info, unsigned int virq,
+			 irq_hw_number_t hwirq, msi_alloc_info_t *arg)
+{
+	struct irq_data *data;
+	pr_devel("apcie_msi_init(%p, %p, %d, 0x%lx, %p)\n", domain, info, virq, hwirq, arg);
+
+	data = irq_domain_get_irq_data(domain, virq);
+	irq_domain_set_info(domain, virq, hwirq, info->chip, info->chip_data,
+			    handle_edge_irq, NULL, "edge");
+	apcie_msi_calc_mask(data);
+	return 0;
+}
+
+static void apcie_msi_free(struct irq_domain *domain,
+			  struct msi_domain_info *info, unsigned int virq)
+{
+	pr_devel("apcie_msi_free(%d)\n", virq);
+}
+
+static struct msi_domain_ops apcie_msi_domain_ops = {
+	.get_hwirq	= apcie_msi_get_hwirq,
+	.msi_init	= apcie_msi_init,
+	.msi_free	= apcie_msi_free,
+};
+
+static struct msi_domain_info apcie_msi_domain_info = {
+	.flags		= MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS,
+	.ops		= &apcie_msi_domain_ops,
+	.chip		= &apcie_msi_controller,
+	.handler	= handle_edge_irq,
+};
+
+struct irq_domain *apcie_create_irq_domain(struct apcie_dev *sc)
+{
+	struct irq_domain *parent;
+	struct irq_alloc_info info;
+
+	sc_dbg("apcie_create_irq_domain\n");
+	if (x86_vector_domain == NULL)
+		return NULL;
+
+	apcie_msi_domain_info.chip_data = (void *)sc;
+
+	init_irq_alloc_info(&info, NULL);
+	info.type = X86_IRQ_ALLOC_TYPE_MSI;
+	info.msi_dev = sc->pdev;
+	parent = irq_remapping_get_ir_irq_domain(&info);
+	if (parent == NULL) {
+		parent = x86_vector_domain;
+	} else {
+		apcie_msi_domain_info.flags |= MSI_FLAG_MULTI_PCI_MSI;
+		apcie_msi_controller.name = "IR-Aeolia-MSI";
+	}
+
+	return msi_create_irq_domain(NULL, &apcie_msi_domain_info, parent);
+}
+
+static int apcie_is_compatible_device(struct pci_dev *dev)
+{
+	if (!dev || dev->vendor != PCI_VENDOR_ID_SONY) {
+		return 0;
+	}
+	return (dev->device == PCI_DEVICE_ID_SONY_AEOLIA_PCIE ||
+		dev->device == PCI_DEVICE_ID_SONY_BELIZE_PCIE ||
+		dev->device == PCI_DEVICE_ID_SONY_BAIKAL_PCIE);
+}
+
+int apcie_assign_irqs(struct pci_dev *dev, int nvec)
+{
+	int ret;
+	unsigned int sc_devfn;
+	struct pci_dev *sc_dev;
+	struct apcie_dev *sc;
+	struct irq_alloc_info info;
+
+	sc_devfn = (dev->devfn & ~7) | AEOLIA_FUNC_ID_PCIE;
+	sc_dev = pci_get_slot(dev->bus, sc_devfn);
+
+	if (!apcie_is_compatible_device(sc_dev)) {
+		dev_err(&dev->dev, "apcie: this is not an Aeolia device\n");
+		ret = -ENODEV;
+		goto fail;
+	}
+	sc = pci_get_drvdata(sc_dev);
+	if (!sc) {
+		dev_err(&dev->dev, "apcie: not ready yet, cannot assign IRQs\n");
+		ret = -ENODEV;
+		goto fail;
+	}
+
+	init_irq_alloc_info(&info, NULL);
+	info.type = X86_IRQ_ALLOC_TYPE_MSI;
+	/* IRQs "come from" function 4 as far as the IOMMU/system see */
+	info.msi_dev = sc->pdev;
+	/* Our hwirq number is function << 8 plus subfunction.
+	 * Subfunction is usually 0 and implicitly increments per hwirq,
+	 * but can also be 0xff to indicate that this is a shared IRQ. */
+	info.msi_hwirq = PCI_FUNC(dev->devfn) << 8;
+
+	dev_dbg(&dev->dev, "apcie_assign_irqs(%d)\n", nvec);
+
+#ifndef QEMU_HACK_NO_IOMMU
+	info.flags = X86_IRQ_ALLOC_CONTIGUOUS_VECTORS;
+	if (!(apcie_msi_domain_info.flags & MSI_FLAG_MULTI_PCI_MSI)) {
+		nvec = 1;
+		info.msi_hwirq |= 0xff; /* Shared IRQ for all subfunctions */
+	}
+#endif
+
+	ret = irq_domain_alloc_irqs(sc->irqdomain, nvec, NUMA_NO_NODE, &info);
+	if (ret >= 0) {
+		dev->irq = ret;
+		ret = nvec;
+	}
+
+fail:
+	dev_dbg(&dev->dev, "apcie_assign_irqs returning %d\n", ret);
+	if (sc_dev)
+		pci_dev_put(sc_dev);
+	return ret;
+}
+EXPORT_SYMBOL(apcie_assign_irqs);
+
+void apcie_free_irqs(unsigned int virq, unsigned int nr_irqs)
+{
+	irq_domain_free_irqs(virq, nr_irqs);
+}
+EXPORT_SYMBOL(apcie_free_irqs);
+
+static void apcie_glue_remove(struct apcie_dev *sc);
+
+static int apcie_glue_init(struct apcie_dev *sc)
+{
+	int i;
+
+	sc_info("apcie glue probe\n");
+
+	if (!request_mem_region(pci_resource_start(sc->pdev, 4) +
+				APCIE_RGN_PCIE_BASE, APCIE_RGN_PCIE_SIZE,
+				"apcie.glue")) {
+		sc_err("Failed to request pcie region\n");
+		return -EBUSY;
+
+	}
+
+	if (!request_mem_region(pci_resource_start(sc->pdev, 2) +
+				APCIE_RGN_CHIPID_BASE, APCIE_RGN_CHIPID_SIZE,
+				"apcie.chipid")) {
+		sc_err("Failed to request chipid region\n");
+		release_mem_region(pci_resource_start(sc->pdev, 4) +
+				   APCIE_RGN_PCIE_BASE, APCIE_RGN_PCIE_SIZE);
+		return -EBUSY;
+	}
+
+	glue_set_region(sc, AEOLIA_FUNC_ID_PCIE, 2, 0xbf018000, 0x7fff);
+
+	sc_info("Aeolia chip revision: %08x:%08x:%08x\n",
+		ioread32(sc->bar2 + APCIE_REG_CHIPID_0),
+		ioread32(sc->bar2 + APCIE_REG_CHIPID_1),
+		ioread32(sc->bar2 + APCIE_REG_CHIPREV));
+
+	/* Mask all MSIs first, to avoid spurious IRQs */
+	for (i = 0; i < AEOLIA_NUM_FUNCS; i++) {
+		glue_write32(sc, APCIE_REG_MSI_MASK(i), 0);
+		glue_write32(sc, APCIE_REG_MSI_ADDR(i), 0);
+		glue_write32(sc, APCIE_REG_MSI_DATA_HI(i), 0);
+	}
+
+	for (i = 0; i < 0xfc; i += 4)
+		glue_write32(sc, APCIE_REG_MSI_DATA_LO(i), 0);
+
+	glue_set_region(sc, AEOLIA_FUNC_ID_GBE, 0, 0xbfa00000, 0x3fff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_AHCI, 5, 0xbfa04000, 0xfff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_SDHCI, 0, 0xbfa80000, 0xfff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_SDHCI, 1, 0, 0);
+	glue_set_region(sc, AEOLIA_FUNC_ID_DMAC, 0, 0xbfa05000, 0xfff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_DMAC, 1, 0, 0);
+	glue_set_region(sc, AEOLIA_FUNC_ID_DMAC, 2, 0xbfa06000, 0xfff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_DMAC, 3, 0, 0);
+	glue_set_region(sc, AEOLIA_FUNC_ID_MEM, 2, 0xc0000000, 0x3fffffff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_MEM, 3, 0, 0);
+	glue_set_region(sc, AEOLIA_FUNC_ID_XHCI, 0, 0xbf400000, 0x1fffff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_XHCI, 1, 0, 0);
+	glue_set_region(sc, AEOLIA_FUNC_ID_XHCI, 2, 0xbf600000, 0x1fffff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_XHCI, 3, 0, 0);
+	glue_set_region(sc, AEOLIA_FUNC_ID_XHCI, 4, 0xbf800000, 0x1fffff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_XHCI, 5, 0, 0);
+
+	sc->irqdomain = apcie_create_irq_domain(sc);
+	if (!sc->irqdomain) {
+		sc_err("Failed to create IRQ domain");
+		apcie_glue_remove(sc);
+		return -EIO;
+	}
+	sc->nvec = apcie_assign_irqs(sc->pdev, APCIE_NUM_SUBFUNC);
+	if (sc->nvec <= 0) {
+		sc_err("Failed to assign IRQs");
+		apcie_glue_remove(sc);
+		return -EIO;
+	}
+	sc_dbg("dev->irq=%d\n", sc->pdev->irq);
+
+	return 0;
+}
+
+static void apcie_glue_remove(struct apcie_dev *sc) {
+	sc_info("apcie glue remove\n");
+
+	if (sc->nvec > 0) {
+		apcie_free_irqs(sc->pdev->irq, sc->nvec);
+		sc->nvec = 0;
+	}
+	if (sc->irqdomain) {
+		irq_domain_remove(sc->irqdomain);
+		sc->irqdomain = NULL;
+	}
+	release_mem_region(pci_resource_start(sc->pdev, 2) +
+			   APCIE_RGN_CHIPID_BASE, APCIE_RGN_CHIPID_SIZE);
+	release_mem_region(pci_resource_start(sc->pdev, 4) +
+			   APCIE_RGN_PCIE_BASE, APCIE_RGN_PCIE_SIZE);
+}
+
+#ifdef CONFIG_PM
+static int apcie_glue_suspend(struct apcie_dev *sc, pm_message_t state) {
+	return 0;
+}
+
+static int apcie_glue_resume(struct apcie_dev *sc) {
+	return 0;
+}
+#endif
+
+
+int apcie_uart_init(struct apcie_dev *sc);
+int apcie_icc_init(struct apcie_dev *sc);
+void apcie_uart_remove(struct apcie_dev *sc);
+void apcie_icc_remove(struct apcie_dev *sc);
+#ifdef CONFIG_PM
+void apcie_uart_suspend(struct apcie_dev *sc, pm_message_t state);
+void apcie_icc_suspend(struct apcie_dev *sc, pm_message_t state);
+void apcie_uart_resume(struct apcie_dev *sc);
+void apcie_icc_resume(struct apcie_dev *sc);
+#endif
+
+/* From arch/x86/platform/ps4/ps4.c */
+extern bool apcie_initialized;
+
+static int apcie_probe(struct pci_dev *dev, const struct pci_device_id *id) {
+	struct apcie_dev *sc;
+	int ret;
+
+	dev_dbg(&dev->dev, "apcie_probe()\n");
+
+	ret = pci_enable_device(dev);
+	if (ret) {
+		dev_err(&dev->dev,
+			"apcie_probe(): pci_enable_device failed: %d\n", ret);
+		return ret;
+	}
+
+	sc = kzalloc(sizeof(*sc), GFP_KERNEL);
+	if (!sc) {
+		dev_err(&dev->dev, "apcie_probe(): alloc sc failed\n");
+		ret = -ENOMEM;
+		goto disable_dev;
+	}
+	sc->pdev = dev;
+	pci_set_drvdata(dev, sc);
+
+	// eMMC ... unused?
+	sc->bar0 = pci_ioremap_bar(dev, 0);
+	// pervasive 0
+	sc->bar2 = pci_ioremap_bar(dev, 2);
+	// pervasive 1 - misc peripherals
+	sc->bar4 = pci_ioremap_bar(dev, 4);
+
+	if (!sc->bar0 || !sc->bar2 || !sc->bar4) {
+		sc_err("failed to map some BARs, bailing out\n");
+		ret = -EIO;
+		goto free_bars;
+	}
+
+	if ((ret = apcie_glue_init(sc)) < 0)
+		goto free_bars;
+	if ((ret = apcie_uart_init(sc)) < 0)
+		goto remove_glue;
+	if ((ret = apcie_icc_init(sc)) < 0)
+		goto remove_uart;
+
+	apcie_initialized = true;
+	return 0;
+
+remove_uart:
+	apcie_uart_remove(sc);
+remove_glue:
+	apcie_glue_remove(sc);
+free_bars:
+	if (sc->bar0)
+		iounmap(sc->bar0);
+	if (sc->bar2)
+		iounmap(sc->bar2);
+	if (sc->bar4)
+		iounmap(sc->bar4);
+	kfree(sc);
+disable_dev:
+	pci_disable_device(dev);
+	return ret;
+}
+
+static void apcie_remove(struct pci_dev *dev) {
+	struct apcie_dev *sc;
+	sc = pci_get_drvdata(dev);
+
+	apcie_icc_remove(sc);
+	apcie_uart_remove(sc);
+	apcie_glue_remove(sc);
+
+	if (sc->bar0)
+		iounmap(sc->bar0);
+	if (sc->bar2)
+		iounmap(sc->bar2);
+	if (sc->bar4)
+		iounmap(sc->bar4);
+	kfree(sc);
+	pci_disable_device(dev);
+}
+
+#ifdef CONFIG_PM
+static int apcie_suspend(struct pci_dev *dev, pm_message_t state) {
+	struct apcie_dev *sc;
+	sc = pci_get_drvdata(dev);
+
+	apcie_icc_suspend(sc, state);
+	apcie_uart_suspend(sc, state);
+	apcie_glue_suspend(sc, state);
+	return 0;
+}
+
+static int apcie_resume(struct pci_dev *dev) {
+	struct apcie_dev *sc;
+	sc = pci_get_drvdata(dev);
+
+	apcie_icc_resume(sc);
+	apcie_glue_resume(sc);
+	apcie_uart_resume(sc);
+	return 0;
+}
+#endif
+
+static const struct pci_device_id apcie_pci_tbl[] = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_AEOLIA_PCIE), },
+	{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_BELIZE_PCIE), },
+	{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_BAIKAL_PCIE), },
+	{ }
+};
+MODULE_DEVICE_TABLE(pci, apcie_pci_tbl);
+
+static struct pci_driver apcie_driver = {
+	.name		= "aeolia_pcie",
+	.id_table	= apcie_pci_tbl,
+	.probe		= apcie_probe,
+	.remove		= apcie_remove,
+#ifdef CONFIG_PM
+	.suspend	= apcie_suspend,
+	.resume		= apcie_resume,
+#endif
+};
+module_pci_driver(apcie_driver);
diff -ruN a/drivers/ps4/ps4-apcie-icc.c b/drivers/ps4/ps4-apcie-icc.c
--- a/drivers/ps4/ps4-apcie-icc.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/ps4/ps4-apcie-icc.c	2022-10-13 06:48:56.634014761 +0200
@@ -0,0 +1,602 @@
+#define DEBUG
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include <asm/ps4.h>
+#include "aeolia.h"
+
+/* There should normally be only one Aeolia device in a system. This allows
+ * other kernel code in unrelated subsystems to issue icc requests without
+ * having to get a reference to the device. */
+static struct apcie_dev *icc_sc;
+DEFINE_MUTEX(icc_mutex);
+
+/* The ICC message passing interface seems to be potentially designed to
+ * support multiple outstanding requests at once, but the original PS4 OS never
+ * does this, so we don't either. */
+
+#define BUF_FULL 0x7f0
+#define BUF_EMPTY 0x7f4
+#define HDR(x) (offsetof(struct icc_message_hdr, x))
+#define REQUEST (sc->icc.spm + APCIE_SPM_ICC_REQUEST)
+#define REPLY (sc->icc.spm + APCIE_SPM_ICC_REPLY)
+
+/* Seconds. Yes, some ICC requests can be slow. */
+int icc_timeout = 15;
+
+int icc_i2c_init(struct apcie_dev *sc);
+void icc_i2c_remove(struct apcie_dev *sc);
+int icc_pwrbutton_init(struct apcie_dev *sc);
+void icc_pwrbutton_remove(struct apcie_dev *sc);
+void icc_pwrbutton_trigger(struct apcie_dev *sc, int state);
+
+#define ICC_MAJOR	'I'
+
+ struct icc_cmd {
+ 	u8 major;
+ 	u16 minor;
+ 	void __user *data;
+ 	u16 length;
+ 	void __user *reply;
+ 	u16 reply_length;
+ };
+
+#define ICC_IOCTL_CMD _IOWR(ICC_MAJOR, 1, struct icc_cmd)
+
+static u16 checksum(const void *p, int length)
+{
+	const u8 *pp = p;
+	u16 sum = 0;
+	while (length--)
+		sum += *pp++;
+	return sum;
+}
+
+static void dump_message(struct apcie_dev *sc, int offset)
+{
+	int len;
+	struct icc_message_hdr hdr;
+	memcpy_fromio(&hdr, sc->icc.spm + offset, ICC_HDR_SIZE);
+
+	sc_err("icc: hdr: [%02x] %02x:%04x unk %x #%d len %d cksum 0x%x\n",
+	       hdr.magic, hdr.major, hdr.minor, hdr.unknown, hdr.cookie,
+	       hdr.length, hdr.checksum);
+	len = min(hdr.length - ICC_HDR_SIZE, ICC_MAX_PAYLOAD);
+	if (len > 0) {
+		sc_err("icc: data:");
+		while (len--)
+			printk(" %02x", ioread8(sc->icc.spm + (offset++) +
+			                         ICC_HDR_SIZE));
+		printk("\n");
+	}
+}
+
+static void handle_event(struct apcie_dev *sc, struct icc_message_hdr *msg)
+{
+	switch ((msg->major << 16) | msg->minor) {
+		case 0x088010:
+			icc_pwrbutton_trigger(sc, 1);
+			break;
+		case 0x088011:
+			icc_pwrbutton_trigger(sc, 0);
+			break;
+		default:
+			sc_err("icc: event arrived, not yet supported.\n");
+			dump_message(sc, APCIE_SPM_ICC_REPLY);
+			break;
+	}
+}
+
+static void handle_message(struct apcie_dev *sc)
+{
+	u32 rep_empty, rep_full;
+	int off, copy_size;
+	struct icc_message_hdr msg;
+
+	rep_empty = ioread32(REPLY + BUF_EMPTY);
+	rep_full = ioread32(REPLY + BUF_FULL);
+
+	if (rep_empty != 0 || rep_full != 1) {
+		sc_err("icc: reply buffer in bad state (%d, %d)\n",
+			rep_empty, rep_full);
+		return;
+	}
+
+	memcpy_fromio(&msg, REPLY, ICC_HDR_SIZE);
+
+	if (msg.minor & ICC_EVENT) {
+		if (msg.magic != ICC_EVENT_MAGIC) {
+			sc_err("icc: event has bad magic\n");
+			dump_message(sc, APCIE_SPM_ICC_REPLY);
+			return;
+		}
+		handle_event(sc, &msg);
+	} else if (msg.minor & ICC_REPLY) {
+		if (msg.magic != ICC_MAGIC) {
+			sc_err("icc: reply has bad magic\n");
+			dump_message(sc, APCIE_SPM_ICC_REPLY);
+			return;
+		}
+		spin_lock(&sc->icc.reply_lock);
+		if (!sc->icc.reply_pending) {
+			spin_unlock(&sc->icc.reply_lock);
+			sc_err("icc: unexpected reply\n");
+			dump_message(sc, APCIE_SPM_ICC_REPLY);
+			return;
+		}
+		if (msg.cookie != sc->icc.request.cookie) {
+			spin_unlock(&sc->icc.reply_lock);
+			sc_err("icc: reply has bad cookie %d\n", msg.cookie);
+			dump_message(sc, APCIE_SPM_ICC_REPLY);
+			return;
+		}
+		if (msg.length < ICC_HDR_SIZE || msg.length > ICC_MAX_SIZE) {
+			spin_unlock(&sc->icc.reply_lock);
+			sc_err("icc: reply has bad length %d\n", msg.length);
+			dump_message(sc, APCIE_SPM_ICC_REPLY);
+			return;
+		}
+		off = ICC_HDR_SIZE;
+		copy_size = min(sc->icc.reply_length,
+				(int)(msg.length - off));
+		memcpy_fromio(sc->icc.reply_buffer, REPLY + off, copy_size);
+		off += copy_size;
+		sc->icc.reply_extra_checksum = 0;
+		while (off < msg.length)
+			sc->icc.reply_extra_checksum += ioread8(REPLY + off++);
+		sc->icc.reply_pending = false;
+		sc->icc.reply_length = copy_size;
+		sc->icc.reply = msg;
+		spin_unlock(&sc->icc.reply_lock);
+		wake_up(&sc->icc.wq);
+	} else {
+		sc_err("icc: unknown message arrived\n");
+		dump_message(sc, APCIE_SPM_ICC_REPLY);
+	}
+}
+
+static irqreturn_t icc_interrupt(int irq, void *arg)
+{
+	struct apcie_dev *sc = arg;
+	u32 status;
+	u32 ret = IRQ_NONE;
+
+	do {
+		status = ioread32(sc->bar4 + APCIE_REG_ICC_STATUS);
+
+		if (status & APCIE_ICC_ACK) {
+			iowrite32(APCIE_ICC_ACK,
+				  sc->bar4 + APCIE_REG_ICC_STATUS);
+			ret = IRQ_HANDLED;
+		}
+
+		if (status & APCIE_ICC_SEND) {
+			iowrite32(APCIE_ICC_SEND,
+				  sc->bar4 + APCIE_REG_ICC_STATUS);
+			handle_message(sc);
+			iowrite32(0, REPLY + BUF_FULL);
+			iowrite32(1, REPLY + BUF_EMPTY);
+			iowrite32(APCIE_ICC_ACK,
+				  sc->bar4 + APCIE_REG_ICC_DOORBELL);
+			ret = IRQ_HANDLED;
+		}
+	} while (status);
+
+	return ret;
+}
+
+static int _apcie_icc_cmd(struct apcie_dev *sc, u8 major, u16 minor, const void *data,
+		    u16 length, void *reply, u16 reply_length, bool intr)
+{
+	int ret;
+	u32 req_empty, req_full;
+	u16 rep_checksum;
+
+	if (length > ICC_MAX_PAYLOAD)
+		return -E2BIG;
+
+	sc->icc.request.magic = ICC_MAGIC;
+	sc->icc.request.major = major;
+	sc->icc.request.minor = minor;
+	sc->icc.request.cookie++;
+	sc->icc.request.length = ICC_HDR_SIZE + length;
+	sc->icc.request.checksum = 0;
+	if (sc->icc.request.length < ICC_MIN_SIZE)
+		sc->icc.request.length = ICC_MIN_SIZE;
+
+	sc->icc.request.checksum = checksum(&sc->icc.request, ICC_HDR_SIZE);
+	sc->icc.request.checksum += checksum(data, length);
+	sc->icc.reply_buffer = reply;
+	sc->icc.reply_length = reply_length;
+
+	req_empty = ioread32(REQUEST + BUF_EMPTY);
+	req_full = ioread32(REQUEST + BUF_FULL);
+
+	if (req_empty != 1 || req_full != 0) {
+		sc_err("icc: request buffer is busy: empty=%d full=%d\n",
+		       req_empty, req_full);
+		return -EIO;
+	}
+
+	iowrite32(0, REQUEST + BUF_EMPTY);
+
+	memcpy_toio(REQUEST, &sc->icc.request, ICC_HDR_SIZE);
+	memcpy_toio(REQUEST + ICC_HDR_SIZE, data, length);
+	if (length < ICC_MIN_PAYLOAD)
+		memset_io(REQUEST + ICC_HDR_SIZE + length, 0,
+			  ICC_MIN_PAYLOAD - length);
+
+	iowrite32(1, REQUEST + BUF_FULL);
+
+	spin_lock_irq(&sc->icc.reply_lock);
+	sc->icc.reply_pending = true;
+	spin_unlock_irq(&sc->icc.reply_lock);
+
+	iowrite32(APCIE_ICC_SEND, sc->bar4 + APCIE_REG_ICC_DOORBELL);
+
+	if (intr)
+		ret = wait_event_interruptible_timeout(sc->icc.wq,
+				!sc->icc.reply_pending, HZ * icc_timeout);
+	else
+		ret = wait_event_timeout(sc->icc.wq,
+				!sc->icc.reply_pending, HZ * icc_timeout);
+
+	spin_lock_irq(&sc->icc.reply_lock);
+	sc->icc.reply_buffer = NULL;
+	if (ret < 0 || sc->icc.reply_pending) { /* interrupted or timed out */
+		sc->icc.reply_pending = false;
+		spin_unlock_irq(&sc->icc.reply_lock);
+		sc_err("icc: interrupted or timeout: ret = %d\n", ret);
+		return ret < 0 ? -EINTR : -ETIMEDOUT;
+	}
+	spin_unlock_irq(&sc->icc.reply_lock);
+
+	rep_checksum = sc->icc.reply.checksum;
+	sc->icc.reply.checksum = 0;
+	rep_checksum -= checksum(&sc->icc.reply, ICC_HDR_SIZE);
+	rep_checksum -= checksum(reply, sc->icc.reply_length);
+	rep_checksum -= sc->icc.reply_extra_checksum;
+
+	if (rep_checksum) {
+		sc_err("icc: checksum mismatch (diff: %x)\n", rep_checksum);
+		return -EIO;
+	}
+
+	if (sc->icc.reply.major != major ) {
+		sc_err("icc: major mismatch\n");
+		return -EIO;
+	}
+	if (sc->icc.reply.minor != (minor | ICC_REPLY) ) {
+		sc_err("icc: minor mismatch\n");
+		return -EIO;
+	}
+
+	return sc->icc.reply.length - ICC_HDR_SIZE;
+}
+
+int apcie_icc_cmd(u8 major, u16 minor, const void *data, u16 length,
+		   void *reply, u16 reply_length)
+{
+	int ret;
+
+	mutex_lock(&icc_mutex);
+	if (!icc_sc) {
+		pr_err("icc: not ready\n");
+		return -EAGAIN;
+	}
+	ret = _apcie_icc_cmd(icc_sc, major, minor, data, length, reply, reply_length,
+		       false);
+	mutex_unlock(&icc_mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(apcie_icc_cmd);
+
+void resetUsbPort(void)
+{
+	u8 off = 0, on = 1;
+	u8 resp[20];
+	int ret;
+	
+	//Turn OFF Usb
+	ret = apcie_icc_cmd(5, 0x10, &off, sizeof(off), resp, 20);
+	printk("Turn OFF USB: ret=%d, reply %02x %02x %02x %02x", ret, resp[0], resp[1], resp[2], resp[3]);
+	if(ret < 0)
+	{
+		printk("Turn off USB failed!");
+		return;
+	}
+	
+	//Turn ON Usb
+	ret = apcie_icc_cmd(5, 0x10, &on, sizeof(on), resp, 20);
+	printk("Turn ON USB: ret=%d, reply %02x %02x %02x %02x", ret, resp[0], resp[1], resp[2], resp[3]);
+	if(ret < 0)
+	{
+		printk("Turn on USB failed");
+		return;
+	}
+}
+
+void resetBtWlan(void)
+{
+	u8 off = 2, on = 3;
+	u8 resp[20];
+	int ret;
+	
+
+	/* Get bt/wlan status */
+//	ret = apcie_icc_cmd(5, 1, NULL, 0, resp, 20);
+//	printk("BT/WLAN status: ret=%d, reply %02x %02x %02x %02x", ret, resp[0], resp[1], resp[2], resp[3]);
+
+	/** Turn off is done from linux-loader actually, if you want you can remove it from linux-loader and done it here **/
+	
+	//Turn OFF bt/wlan
+/*	ret = apcie_icc_cmd(5, 0, &off, sizeof(off), resp, 20);
+	printk("Turn OFF BT/WLAN: ret=%d, reply %02x %02x %02x %02x", ret, resp[0], resp[1], resp[2], resp[3]);
+	if(ret < 0)
+	{
+		printk("Turn off bt/wlan failed!");
+		return;
+	}
+*/
+
+	//Turn ON bt/wlan
+	ret = apcie_icc_cmd(5, 0, &on, sizeof(on), resp, 20);
+	printk("Turn ON BT/WLAN: ret=%d, reply %02x %02x %02x %02x", ret, resp[0], resp[1], resp[2], resp[3]);
+	if(ret < 0)
+	{
+		printk("Turn on bt/wlan failed");
+		return;
+	}
+}
+
+void do_icc_init(void) {
+	u8 svc = 0x10;
+	u8 reply[0x30];
+	static const u8 led_config[] = {
+		3, 1, 0, 0,
+			0x10, 1, /* Blue: on */
+				2, 0xff, 2, 1, 0x00,
+			0x11, 1, /* White: off */
+				2, 0x00, 2, 1, 0x00,
+			0x02, 3, /* Orange: delay and pulse, loop forever */
+				1, 0x00, 4, 1, 0xbf,
+				2, 0xff, 5, 1, 0xff,
+				2, 0x00, 5, 1, 0xff,
+	};
+	int ret;
+	// test: get FW version
+	ret = apcie_icc_cmd(2, 6, NULL, 0, reply, 0x30);
+	printk("ret=%d, reply %02x %02x %02x %02x %02x %02x %02x %02x\n", ret,
+		reply[0], reply[1], reply[2], reply[3],
+		reply[4], reply[5], reply[6], reply[7]);
+	ret = apcie_icc_cmd(1, 0, &svc, 1, reply, 0x30);
+	printk("ret=%d, reply %02x %02x %02x %02x %02x %02x %02x %02x\n", ret,
+		reply[0], reply[1], reply[2], reply[3],
+		reply[4], reply[5], reply[6], reply[7]);
+
+	/* Set the LED to something nice */
+	ret = apcie_icc_cmd(9, 0x20, led_config, ARRAY_SIZE(led_config), reply, 0x30);
+	printk("ret=%d, reply %02x %02x %02x %02x %02x %02x %02x %02x\n", ret,
+		reply[0], reply[1], reply[2], reply[3],
+		reply[4], reply[5], reply[6], reply[7]);
+}
+
+static void icc_shutdown(void)
+{
+	uint8_t command[] = {
+		0, 0, 2, 0, 1, 0
+	};
+	if (apcie_status() != 1)
+		return;
+	apcie_icc_cmd(4, 1, command, sizeof(command), NULL, 0);
+	mdelay(3000);
+	WARN_ON(1);
+}
+
+void icc_reboot(void)
+{
+	uint8_t command[] = {
+		0, 1, 2, 0, 1, 0
+	};
+	if (apcie_status() != 1)
+		return;
+	apcie_icc_cmd(4, 1, command, sizeof(command), NULL, 0);
+	mdelay(3000);
+	WARN_ON(1);
+}
+
+static void *ioctl_tmp_buf = NULL;
+
+ static long icc_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+ {
+ 	int ret;
+ 	void __user *uap = (void __user *)arg;
+ 	switch (cmd) {
+ 	case ICC_IOCTL_CMD: {
+ 		struct icc_cmd cmd;
+ 		int reply_len;
+ 		ret = copy_from_user(&cmd, uap, sizeof(cmd));
+ 		if (ret) {
+ 			ret = -EFAULT;
+ 			break;
+ 		}
+ 		ret = copy_from_user(ioctl_tmp_buf, cmd.data, cmd.length);
+ 		if (ret) {
+ 			ret = -EFAULT;
+ 			break;
+ 		}
+ 		reply_len = apcie_icc_cmd(cmd.major, cmd.minor, ioctl_tmp_buf,
+ 			cmd.length, ioctl_tmp_buf, cmd.reply_length);
+ 		if (reply_len < 0) {
+ 			ret = reply_len;
+ 			break;
+ 		}
+ 		ret = copy_to_user(cmd.reply, ioctl_tmp_buf, cmd.reply_length);
+ 		if (ret) {
+ 			ret = -EFAULT;
+ 			break;
+ 		}
+ 		ret = reply_len;
+ 		} break;
+ 	default:
+ 		ret = -ENOENT;
+ 		break;
+ 	}
+ 	return ret;
+ }
+
+ static const struct file_operations icc_fops = {
+ 	.owner = THIS_MODULE,
+ 	.unlocked_ioctl = icc_ioctl,
+ };
+
+
+int apcie_icc_init(struct apcie_dev *sc)
+{
+	int ret;
+	unsigned int mem_devfn = PCI_DEVFN(PCI_SLOT(sc->pdev->devfn), AEOLIA_FUNC_ID_MEM);
+	struct pci_dev *mem_dev;
+	u32 req_empty, req_full;
+
+	/* ICC makes use of a segment of SPM memory, available via a different
+	 * PCI function in Aeolia, so we need to get a handle to it. */
+	mem_dev = pci_get_slot(sc->pdev->bus, mem_devfn);
+	if (!mem_dev) {
+		sc_err("icc: could not get handle to mem device\n");
+		return -ENODEV;
+	}
+
+	if (!request_mem_region(pci_resource_start(sc->pdev, 4) +
+				APCIE_RGN_ICC_BASE, APCIE_RGN_ICC_SIZE,
+				"apcie.icc")) {
+		sc_err("icc: failed to request ICC register region\n");
+		return -EBUSY;
+	}
+
+	sc->icc.spm_base = pci_resource_start(mem_dev, 5) + APCIE_SPM_ICC_BASE;
+	if (!request_mem_region(sc->icc.spm_base, APCIE_SPM_ICC_SIZE,
+				"spm.icc")) {
+		sc_err("icc: failed to request ICC SPM region\n");
+		ret = -EBUSY;
+		goto release_icc;
+	}
+
+	sc->icc.spm = ioremap(sc->icc.spm_base, APCIE_SPM_ICC_SIZE);
+	if (!sc->icc.spm) {
+		sc_err("icc: failed to map ICC portion of SPM\n");
+		ret = -EIO;
+		goto release_spm;
+	}
+
+	spin_lock_init(&sc->icc.reply_lock);
+	init_waitqueue_head(&sc->icc.wq);
+
+	/* Clear flags */
+	iowrite32(APCIE_ICC_SEND | APCIE_ICC_ACK,
+		  sc->bar4 + APCIE_REG_ICC_STATUS);
+
+	ret = request_irq(apcie_irqnum(sc, APCIE_SUBFUNC_ICC),
+			  icc_interrupt, IRQF_SHARED, "icc", sc);
+	if (ret) {
+		sc_err("icc: could not request IRQ: %d\n", ret);
+		goto iounmap;
+	}
+
+	req_empty = ioread32(REQUEST + BUF_EMPTY);
+	req_full = ioread32(REQUEST + BUF_FULL);
+
+	if (req_empty != 1 || req_full != 0) {
+		sc_err("icc: request buffer is busy: empty=%d full=%d\n",
+		       req_empty, req_full);
+		ret = -EIO;
+		goto free_irq;
+	}
+
+	mutex_lock(&icc_mutex);
+	icc_sc = sc;
+
+	/* Enable IRQs */
+	iowrite32(APCIE_ICC_SEND | APCIE_ICC_ACK,
+		  sc->bar4 + APCIE_REG_ICC_IRQ_MASK);
+	mutex_unlock(&icc_mutex);
+
+	ret = icc_i2c_init(sc);
+	if (ret) {
+		sc_err("icc: i2c init failed: %d\n", ret);
+		goto unassign_global;
+	}
+	
+	resetBtWlan();
+//	resetUsbPort();
+	
+	ret = icc_pwrbutton_init(sc);
+	/* Not fatal */
+	if (ret)
+		sc_err("icc: pwrbutton init failed: %d\n", ret);
+
+	do_icc_init();
+	pm_power_off = &icc_shutdown;
+
+	ioctl_tmp_buf = kzalloc(1 << 16, GFP_KERNEL);
+ 	if (!ioctl_tmp_buf) {
+ 		sc_err("icc: alloc ioctl_tmp_buf failed\n");
+ 		goto done;
+ 	}
+ 	ret = register_chrdev(ICC_MAJOR, "icc", &icc_fops);
+ 	if (ret) {
+ 		sc_err("icc: register_chrdev failed: %d\n", ret);
+ 		goto done;
+ 	}
+ done:
+
+	return 0;
+
+unassign_global:
+	mutex_lock(&icc_mutex);
+	iowrite32(0, sc->bar4 + APCIE_REG_ICC_IRQ_MASK);
+	icc_sc = NULL;
+	mutex_unlock(&icc_mutex);
+free_irq:
+	free_irq(apcie_irqnum(sc, APCIE_SUBFUNC_ICC), sc);
+iounmap:
+	iounmap(sc->icc.spm);
+release_spm:
+	release_mem_region(sc->icc.spm_base, APCIE_SPM_ICC_SIZE);
+release_icc:
+	release_mem_region(pci_resource_start(sc->pdev, 4) +
+			   APCIE_RGN_ICC_BASE, APCIE_RGN_ICC_SIZE);
+	return ret;
+}
+
+void apcie_icc_remove(struct apcie_dev *sc)
+{
+	sc_err("apcie_icc_remove: shouldn't normally be called\n");
+	pm_power_off = NULL;
+	icc_pwrbutton_remove(sc);
+	icc_i2c_remove(sc);
+	mutex_lock(&icc_mutex);
+	iowrite32(0, sc->bar4 + APCIE_REG_ICC_IRQ_MASK);
+	icc_sc = NULL;
+	mutex_unlock(&icc_mutex);
+	free_irq(apcie_irqnum(sc, APCIE_SUBFUNC_ICC), sc);
+	iounmap(sc->icc.spm);
+	release_mem_region(sc->icc.spm_base, APCIE_SPM_ICC_SIZE);
+	release_mem_region(pci_resource_start(sc->pdev, 4) +
+			   APCIE_RGN_ICC_BASE, APCIE_RGN_ICC_SIZE);
+}
+
+#ifdef CONFIG_PM
+void apcie_icc_suspend(struct apcie_dev *sc, pm_message_t state)
+{
+}
+
+void apcie_icc_resume(struct apcie_dev *sc)
+{
+}
+#endif
diff -ruN a/drivers/ps4/ps4-apcie-pwrbutton.c b/drivers/ps4/ps4-apcie-pwrbutton.c
--- a/drivers/ps4/ps4-apcie-pwrbutton.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/ps4/ps4-apcie-pwrbutton.c	2022-10-13 06:48:56.634014761 +0200
@@ -0,0 +1,69 @@
+#include <linux/input.h>
+#include "aeolia.h"
+
+void icc_pwrbutton_trigger(struct apcie_dev *sc, int state)
+{
+	if (sc->icc.pwrbutton_dev) {
+		input_report_key(sc->icc.pwrbutton_dev, KEY_POWER, state ? 1 : 0);
+		input_sync(sc->icc.pwrbutton_dev);
+	}
+}
+
+int icc_pwrbutton_init(struct apcie_dev *sc)
+{
+	int ret = 0;
+	u16 button;
+	struct input_dev *dev;
+
+	dev = input_allocate_device();
+	if (!dev) {
+		sc_err("%s: Not enough memory.\n", __func__);
+		return -ENOMEM;
+	}
+
+	set_bit(EV_KEY, dev->evbit);
+	set_bit(KEY_POWER, dev->keybit);
+
+	dev->name = "Power Button";
+	dev->id.bustype = BUS_HOST;
+
+	/* this makes the button look like an acpi power button
+	 * no clue whether anyone relies on that though */
+	dev->id.product = 0x02;
+	dev->phys = "LNXPWRBN/button/input0";
+
+	dev->dev.parent = &sc->pdev->dev;
+	ret = input_register_device(dev);
+	if (ret) {
+		sc_err("%s: Failed to register device\n", __func__);
+		input_free_device(dev);
+		return ret;
+	}
+
+	sc->icc.pwrbutton_dev = dev;
+
+	// enable power button notifications
+	button = 0x100;
+	ret = apcie_icc_cmd(8, 1, &button, sizeof(button), NULL, 0);
+	if (ret < 0) {
+		sc_info("%s: Failed to enable power notifications (%d)\n",
+			__func__, ret);
+	}
+
+	// enable reset button notifications (?)
+	button = 0x102;
+	ret = apcie_icc_cmd(8, 1, &button, sizeof(button), NULL, 0);
+	if (ret < 0) {
+		sc_info("%s: Failed to enable reset notifications (%d)\n",
+		        __func__, ret);
+	}
+
+	return 0;
+}
+
+void icc_pwrbutton_remove(struct apcie_dev *sc)
+{
+	if (sc->icc.pwrbutton_dev)
+		input_free_device(sc->icc.pwrbutton_dev);
+	sc->icc.pwrbutton_dev = NULL;
+}
diff -ruN a/drivers/ps4/ps4-apcie-uart.c b/drivers/ps4/ps4-apcie-uart.c
--- a/drivers/ps4/ps4-apcie-uart.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/ps4/ps4-apcie-uart.c	2022-10-13 06:48:56.634014761 +0200
@@ -0,0 +1,67 @@
+#include <linux/serial_8250.h>
+#include <linux/serial_core.h>
+#include <linux/serial_reg.h>
+
+#include "aeolia.h"
+
+void apcie_uart_remove(struct apcie_dev *sc);
+
+int apcie_uart_init(struct apcie_dev *sc)
+{
+	int i;
+	struct uart_8250_port uart;
+
+	for (i = 0; i < APCIE_NR_UARTS; i++) {
+		sc->serial_line[i] = -1;
+	}
+
+	for (i = 0; i < APCIE_NR_UARTS; i++) {
+		uint32_t off = APCIE_RGN_UART_BASE + (i << 12);
+		memset(&uart, 0, sizeof(uart));
+		uart.port.irq		= apcie_irqnum(sc, APCIE_SUBFUNC_UART0 + i);
+		uart.port.uartclk	= 58500000;
+		uart.port.flags		= UPF_SHARE_IRQ;
+		uart.port.iotype	= UPIO_MEM32;
+		uart.port.mapbase	= pci_resource_start(sc->pdev, 4) + off;
+		uart.port.membase	= sc->bar4 + off;
+		uart.port.regshift	= 2;
+		uart.port.dev		= &sc->pdev->dev;
+
+		sc->serial_line[i] = serial8250_register_8250_port(&uart);
+		if (sc->serial_line[i] < 0) {
+			sc_err("Failed to register serial port %d\n", i);
+			apcie_uart_remove(sc);
+			return -EIO;
+		}
+	}
+	return 0;
+}
+
+void apcie_uart_remove(struct apcie_dev *sc)
+{
+	int i;
+	for (i = 0; i < APCIE_NR_UARTS; i++) {
+		if (sc->serial_line[i] >= 0) {
+			serial8250_unregister_port(sc->serial_line[i]);
+			sc->serial_line[i] = -1;
+		}
+	}
+}
+
+#ifdef CONFIG_PM
+void apcie_uart_suspend(struct apcie_dev *sc, pm_message_t state)
+{
+	int i;
+	for (i = 0; i < APCIE_NR_UARTS; i++)
+		if (sc->serial_line[i] >= 0)
+			serial8250_suspend_port(sc->serial_line[i]);
+}
+
+void apcie_uart_resume(struct apcie_dev *sc)
+{
+	int i;
+	for (i = 0; i < APCIE_NR_UARTS; i++)
+		if (sc->serial_line[i] >= 0)
+			serial8250_resume_port(sc->serial_line[i]);
+}
+#endif
diff -ruN a/drivers/usb/host/Kconfig b/drivers/usb/host/Kconfig
--- a/drivers/usb/host/Kconfig	2022-10-13 07:15:21.533052995 +0200
+++ b/drivers/usb/host/Kconfig	2022-10-13 06:48:56.634014761 +0200
@@ -93,6 +93,13 @@
 	---help---
 	  Say 'Y' to enable the support for the xHCI host controller
 	  found in NVIDIA Tegra124 and later SoCs.
+		
+config USB_XHCI_AEOLIA
+	tristate "xHCI support for Sony PS4 (Aeolia)"
+	depends on X86_PS4
+	---help---
+	  Say 'Y' to enable the support for the xHCI host controller
+	  found in the Sony PlayStation 4.
 
 endif # USB_XHCI_HCD
 
diff -ruN a/drivers/usb/host/Makefile b/drivers/usb/host/Makefile
--- a/drivers/usb/host/Makefile	2022-10-13 07:15:21.533052995 +0200
+++ b/drivers/usb/host/Makefile	2022-10-13 06:48:56.634014761 +0200
@@ -78,6 +78,7 @@
 obj-$(CONFIG_USB_XHCI_HISTB)	+= xhci-histb.o
 obj-$(CONFIG_USB_XHCI_MTK)	+= xhci-mtk.o
 obj-$(CONFIG_USB_XHCI_TEGRA)	+= xhci-tegra.o
+obj-$(CONFIG_USB_XHCI_AEOLIA)	+= xhci-aeolia.o
 obj-$(CONFIG_USB_SL811_HCD)	+= sl811-hcd.o
 obj-$(CONFIG_USB_SL811_CS)	+= sl811_cs.o
 obj-$(CONFIG_USB_U132_HCD)	+= u132-hcd.o
diff -ruN a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c
--- a/drivers/usb/host/xhci.c	2022-10-13 07:15:21.535053044 +0200
+++ b/drivers/usb/host/xhci.c	2022-10-13 06:48:56.635014786 +0200
@@ -5218,22 +5218,23 @@
 
 	/* Set dma_mask and coherent_dma_mask to 64-bits,
 	 * if xHC supports 64-bit addressing */
-	if (HCC_64BIT_ADDR(xhci->hcc_params) &&
-			!dma_set_mask(dev, DMA_BIT_MASK(64))) {
-		xhci_dbg(xhci, "Enabling 64-bit DMA addresses.\n");
-		dma_set_coherent_mask(dev, DMA_BIT_MASK(64));
-	} else {
-		/*
-		 * This is to avoid error in cases where a 32-bit USB
-		 * controller is used on a 64-bit capable system.
-		 */
-		retval = dma_set_mask(dev, DMA_BIT_MASK(32));
-		if (retval)
-			return retval;
-		xhci_dbg(xhci, "Enabling 32-bit DMA addresses.\n");
-		dma_set_coherent_mask(dev, DMA_BIT_MASK(32));
+ 	if (!(xhci->quirks & XHCI_PLAT_DMA)) {
+		if (HCC_64BIT_ADDR(xhci->hcc_params) &&
+				!dma_set_mask(dev, DMA_BIT_MASK(64))) {
+			xhci_dbg(xhci, "Enabling 64-bit DMA addresses.\n");
+			dma_set_coherent_mask(dev, DMA_BIT_MASK(64));
+		} else {
+			/*
+			 * This is to avoid error in cases where a 32-bit USB
+			 * controller is used on a 64-bit capable system.
+			 */
+			retval = dma_set_mask(dev, DMA_BIT_MASK(32));
+			if (retval)
+				return retval;
+			xhci_dbg(xhci, "Enabling 32-bit DMA addresses.\n");
+			dma_set_coherent_mask(dev, DMA_BIT_MASK(32));
+		}
 	}
-
 	xhci_dbg(xhci, "Calling HCD init\n");
 	/* Initialize HCD and host controller data structures. */
 	retval = xhci_init(hcd);
diff -ruN a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h
--- a/drivers/usb/host/xhci.h	2022-10-13 07:15:21.535053044 +0200
+++ b/drivers/usb/host/xhci.h	2022-10-13 06:48:56.635014786 +0200
@@ -1877,6 +1877,7 @@
 #define XHCI_RESET_PLL_ON_DISCONNECT	BIT_ULL(34)
 #define XHCI_SNPS_BROKEN_SUSPEND    BIT_ULL(35)
 #define XHCI_DISABLE_SPARSE	BIT_ULL(38)
+#define XHCI_PLAT_DMA		BIT_ULL(39)
 
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;
diff -ruN a/include/drm/amd_asic_type.h b/include/drm/amd_asic_type.h
--- a/include/drm/amd_asic_type.h	2022-10-13 07:15:22.493076329 +0200
+++ b/include/drm/amd_asic_type.h	2022-10-13 06:52:20.422164725 +0200
@@ -34,6 +34,8 @@
 	CHIP_BONAIRE,
 	CHIP_KAVERI,
 	CHIP_KABINI,
+	CHIP_LIVERPOOL,
+	CHIP_GLADIUS,
 	CHIP_HAWAII,
 	CHIP_MULLINS,
 	CHIP_TOPAZ,
diff -ruN a/include/linux/pci_ids.h b/include/linux/pci_ids.h
--- a/include/linux/pci_ids.h	2022-10-13 07:15:22.447075211 +0200
+++ b/include/linux/pci_ids.h	2022-10-13 06:48:56.635014786 +0200
@@ -885,6 +885,30 @@
 #define PCI_DEVICE_ID_TI_DRA72x		0xb501
 
 #define PCI_VENDOR_ID_SONY		0x104d
+#define PCI_DEVICE_ID_SONY_AEOLIA_ACPI	0x908f
+#define PCI_DEVICE_ID_SONY_AEOLIA_GBE	0x909e
+#define PCI_DEVICE_ID_SONY_AEOLIA_AHCI	0x909f
+#define PCI_DEVICE_ID_SONY_AEOLIA_SDHCI	0x90a0
+#define PCI_DEVICE_ID_SONY_AEOLIA_PCIE	0x90a1
+#define PCI_DEVICE_ID_SONY_AEOLIA_DMAC	0x90a2
+#define PCI_DEVICE_ID_SONY_AEOLIA_MEM	0x90a3
+#define PCI_DEVICE_ID_SONY_AEOLIA_XHCI	0x90a4
+#define PCI_DEVICE_ID_SONY_BELIZE_ACPI	0x90c8
+#define PCI_DEVICE_ID_SONY_BELIZE_GBE	0x90c9
+#define PCI_DEVICE_ID_SONY_BELIZE_AHCI	0x90ca
+#define PCI_DEVICE_ID_SONY_BELIZE_SDHCI	0x90cb
+#define PCI_DEVICE_ID_SONY_BELIZE_PCIE	0x90cc
+#define PCI_DEVICE_ID_SONY_BELIZE_DMAC	0x90cd
+#define PCI_DEVICE_ID_SONY_BELIZE_MEM	0x90ce
+#define PCI_DEVICE_ID_SONY_BELIZE_XHCI	0x90cf
+#define PCI_DEVICE_ID_SONY_BAIKAL_ACPI	0x90d7
+#define PCI_DEVICE_ID_SONY_BAIKAL_GBE	0x90d8
+#define PCI_DEVICE_ID_SONY_BAIKAL_AHCI	0x90d9
+#define PCI_DEVICE_ID_SONY_BAIKAL_SDHCI	0x90da
+#define PCI_DEVICE_ID_SONY_BAIKAL_PCIE	0x90db
+#define PCI_DEVICE_ID_SONY_BAIKAL_DMAC	0x90dc
+#define PCI_DEVICE_ID_SONY_BAIKAL_MEM	0x90dd
+#define PCI_DEVICE_ID_SONY_BAIKAL_XHCI	0x90de
 
 /* Winbond have two vendor IDs! See 0x10ad as well */
 #define PCI_VENDOR_ID_WINBOND2		0x1050
diff -ruN a/Module.symvers b/Module.symvers
diff --git a/drivers/ata/ahci.c b/drivers/ata/ahci.c
index f003e301723a4a..87e97184b6ffb8 100644
--- a/drivers/ata/ahci.c
+++ b/drivers/ata/ahci.c
@@ -50,6 +50,10 @@
 #include <linux/io-64-nonatomic-lo-hi.h>
 #include "ahci.h"
 
+#ifdef CONFIG_X86_PS4
+#include <asm/ps4.h>
+#endif
+
 #define DRV_NAME	"ahci"
 #define DRV_VERSION	"3.0"
 
@@ -568,6 +572,11 @@ static const struct pci_device_id ahci_pci_tbl[] = {
 	/* Enmotus */
 	{ PCI_DEVICE(0x1c44, 0x8000), board_ahci },
 
+	/* Sony (PS4) */
+	{ PCI_VDEVICE(SONY, PCI_DEVICE_ID_SONY_AEOLIA_AHCI), board_ahci },
+	{ PCI_VDEVICE(SONY, PCI_DEVICE_ID_SONY_BELIZE_AHCI), board_ahci },
+	{ PCI_VDEVICE(SONY, PCI_DEVICE_ID_SONY_BAIKAL_AHCI), board_ahci },
+
 	/* Generic, PCI class code for AHCI */
 	{ PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID,
 	  PCI_CLASS_STORAGE_SATA_AHCI, 0xffffff, board_ahci },
@@ -911,7 +920,22 @@ static int ahci_configure_dma_masks(struct pci_dev *pdev, int using_dac)
 	 */
 	if (pdev->dma_mask && pdev->dma_mask < DMA_BIT_MASK(32))
 		return 0;
-
+#ifdef CONFIG_X86_PS4
+	if (pdev->vendor == PCI_VENDOR_ID_SONY) {
+		rc = dma_set_mask(&pdev->dev, DMA_BIT_MASK(31));
+		if (rc) {
+			dev_err(&pdev->dev, "31-bit DMA enable failed\n");
+			return rc;
+		}
+		rc = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(31));
+		if (rc) {
+			dev_err(&pdev->dev,
+				"31-bit consistent DMA enable failed\n");
+			return rc;
+		}
+		return 0;
+	}
+#endif
 	if (using_dac &&
 	    !dma_set_mask(&pdev->dev, DMA_BIT_MASK(64))) {
 		rc = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(64));
@@ -1552,6 +1576,11 @@ static int ahci_init_msi(struct pci_dev *pdev, unsigned int n_ports,
 {
 	int nvec;
 
+#ifdef CONFIG_X86_PS4
+	if (pdev->vendor == PCI_VENDOR_ID_SONY) {
+		return apcie_assign_irqs(pdev, n_ports);
+	}
+#endif
 	if (hpriv->flags & AHCI_HFLAG_NO_MSI)
 		return -ENODEV;
 
@@ -1604,7 +1633,11 @@ static int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 	VPRINTK("ENTER\n");
 
 	WARN_ON((int)ATA_MAX_QUEUE > AHCI_MAX_CMDS);
-
+#ifdef CONFIG_X86_PS4
+	/* This will return negative on non-PS4 platforms */
+	if (apcie_status() == 0)
+		return -EPROBE_DEFER;
+#endif
 	ata_print_version_once(&pdev->dev, DRV_VERSION);
 
 	/* The AHCI driver can only drive the SATA ports, the PATA driver
@@ -1827,6 +1860,11 @@ static void ahci_remove_one(struct pci_dev *pdev)
 {
 	pm_runtime_get_noresume(&pdev->dev);
 	ata_pci_remove_one(pdev);
+#ifdef CONFIG_X86_PS4
+	if (pdev->vendor == PCI_VENDOR_ID_SONY) {
+		apcie_free_irqs(pdev->irq, 1);
+	}
+#endif
 }
 
 module_pci_driver(ahci_pci_driver);
diff --git a/drivers/usb/host/xhci-aeolia.c b/drivers/usb/host/xhci-aeolia.c
new file mode 100644
index 00000000000000..6bc0cb03ceb376
--- /dev/null
+++ b/drivers/usb/host/xhci-aeolia.c
@@ -0,0 +1,304 @@
+/*
+ * xhci-aeoliat.c - xHCI host controller driver for Aeolia (Sony PS4)
+ *
+ * Borrows code from xhci-pci.c, hcd-pci.c, and xhci-plat.c.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/acpi.h>
+#include <asm/ps4.h>
+
+#include "xhci.h"
+
+static const char hcd_name[] = "xhci_aeolia";
+
+static struct hc_driver __read_mostly xhci_aeolia_hc_driver;
+
+#define NR_DEVICES 3
+
+struct aeolia_xhci {
+	int nr_irqs;
+	struct usb_hcd *hcd[NR_DEVICES];
+};
+
+static int xhci_aeolia_setup(struct usb_hcd *hcd);
+
+static const struct xhci_driver_overrides xhci_aeolia_overrides __initconst = {
+	.extra_priv_size = sizeof(struct xhci_hcd),
+	.reset = xhci_aeolia_setup,
+};
+
+static void xhci_aeolia_quirks(struct device *dev, struct xhci_hcd *xhci)
+{
+	/*
+	 * Do not try to enable MSIs, we provide the MSIs ourselves
+	 * Do not touch DMA mask, we need a custom one
+	 */
+	xhci->quirks |= XHCI_PLAT | XHCI_PLAT_DMA;
+}
+
+/* called during probe() after chip reset completes */
+static int xhci_aeolia_setup(struct usb_hcd *hcd)
+{
+	return xhci_gen_setup(hcd, xhci_aeolia_quirks);
+}
+
+static int xhci_aeolia_probe_one(struct pci_dev *dev, int index)
+{
+	int retval;
+	struct aeolia_xhci *axhci = pci_get_drvdata(dev);
+	struct hc_driver *driver = &xhci_aeolia_hc_driver;
+	struct usb_hcd *hcd;
+	struct xhci_hcd *xhci;
+	int irq = (axhci->nr_irqs > 1) ? (dev->irq + index) : dev->irq;
+
+	// ok...adding this printk appears to have introduced a delay that fixed
+	// bringup of the middle host controller, so w/e for now...
+	
+	printk("xhci_aeolia_probe_one %d, controller is %x\n", index, dev->device);
+
+	hcd = usb_create_hcd(driver, &dev->dev, pci_name(dev));
+	pci_set_drvdata(dev, axhci); /* usb_create_hcd clobbers this */
+	if (!hcd)
+		return -ENOMEM;
+
+	hcd->rsrc_start = pci_resource_start(dev, 2 * index);
+	hcd->rsrc_len = pci_resource_len(dev, 2 * index);
+	if (!request_mem_region(hcd->rsrc_start, hcd->rsrc_len,
+			driver->description)) {
+		dev_dbg(&dev->dev, "controller already in use\n");
+		retval = -EBUSY;
+		goto put_hcd;
+	}
+	hcd->regs = pci_ioremap_bar(dev, 2 * index);
+	if (hcd->regs == NULL) {
+		dev_dbg(&dev->dev, "error mapping memory\n");
+		retval = -EFAULT;
+		goto release_mem_region;
+	}
+
+	device_wakeup_enable(hcd->self.controller);
+
+	xhci = hcd_to_xhci(hcd);
+	xhci->main_hcd = hcd;
+	xhci->shared_hcd = usb_create_shared_hcd(driver, &dev->dev,
+			pci_name(dev), hcd);
+	if (!xhci->shared_hcd) {
+		retval = -ENOMEM;
+		goto unmap_registers;
+	}
+
+	retval = usb_add_hcd(hcd, irq, IRQF_SHARED);
+	if (retval)
+		goto put_usb3_hcd;
+
+	retval = usb_add_hcd(xhci->shared_hcd, irq, IRQF_SHARED);
+	if (retval)
+		goto dealloc_usb2_hcd;
+
+	axhci->hcd[index] = hcd;
+
+	return 0;
+
+dealloc_usb2_hcd:
+	usb_remove_hcd(hcd);
+put_usb3_hcd:
+	usb_put_hcd(xhci->shared_hcd);
+unmap_registers:
+	iounmap(hcd->regs);
+release_mem_region:
+	release_mem_region(hcd->rsrc_start, hcd->rsrc_len);
+put_hcd:
+	usb_put_hcd(hcd);
+	dev_err(&dev->dev, "init %s(%d) fail, %d\n",
+			pci_name(dev), index, retval);
+	return retval;
+}
+
+static void xhci_aeolia_remove_one(struct pci_dev *dev, int index)
+{
+	struct aeolia_xhci *axhci = pci_get_drvdata(dev);
+	struct usb_hcd *hcd = axhci->hcd[index];
+	struct xhci_hcd *xhci;
+
+	if (!hcd)
+		return;
+	xhci = hcd_to_xhci(hcd);
+
+	usb_remove_hcd(xhci->shared_hcd);
+	usb_remove_hcd(hcd);
+	usb_put_hcd(xhci->shared_hcd);
+	usb_put_hcd(hcd);
+	axhci->hcd[index] = NULL;
+}
+
+
+static int xhci_aeolia_probe(struct pci_dev *dev, const struct pci_device_id *id)
+{
+	int idx;
+	int retval;
+	struct aeolia_xhci *axhci;
+
+	if (apcie_status() == 0)
+		return -EPROBE_DEFER;
+
+	if (pci_enable_device(dev) < 0)
+		return -ENODEV;
+
+	axhci = kzalloc(sizeof(*axhci), GFP_KERNEL);
+	if (!axhci) {
+		retval = -ENOMEM;
+		goto disable_device;
+	}
+	pci_set_drvdata(dev, axhci);
+
+	axhci->nr_irqs = retval = apcie_assign_irqs(dev, NR_DEVICES);
+	if (retval < 0) {
+		goto free_axhci;
+	}
+
+	pci_set_master(dev);
+
+	if (pci_set_dma_mask(dev, DMA_BIT_MASK(31)) ||
+		pci_set_consistent_dma_mask(dev, DMA_BIT_MASK(31))) {
+		return -ENODEV;
+	}
+
+	for (idx = 0; idx < NR_DEVICES; idx++) {
+ 		if(dev->device != PCI_DEVICE_ID_SONY_AEOLIA_XHCI && idx == 1) 
+			continue;
+		retval = xhci_aeolia_probe_one(dev, idx);
+		if (retval)
+			goto remove_hcds;
+	}
+
+	return 0;
+
+remove_hcds:
+	while (idx--)
+		xhci_aeolia_remove_one(dev, idx);
+	apcie_free_irqs(dev->irq, axhci->nr_irqs);
+free_axhci:
+	kfree(axhci);
+disable_device:
+	pci_disable_device(dev);
+	return retval;
+}
+
+static void xhci_aeolia_remove(struct pci_dev *dev)
+{
+	int idx;
+	struct aeolia_xhci *axhci = pci_get_drvdata(dev);
+
+	for (idx = 0; idx < NR_DEVICES; idx++) {
+		if(dev->device != PCI_DEVICE_ID_SONY_AEOLIA_XHCI) {
+			if(idx != 1)
+				xhci_aeolia_remove_one(dev, idx);
+		}
+		else
+			xhci_aeolia_remove_one(dev, idx);
+	}
+	
+	apcie_free_irqs(dev->irq, axhci->nr_irqs);
+	kfree(axhci);
+	pci_disable_device(dev);
+}
+
+
+static const struct pci_device_id pci_ids[] = {
+		{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_AEOLIA_XHCI) },
+		{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_BELIZE_XHCI) },
+		{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_BAIKAL_XHCI) },
+	{ /* end: all zeroes */ }
+};
+MODULE_DEVICE_TABLE(pci, pci_ids);
+
+#ifdef CONFIG_PM_SLEEP
+static int xhci_aeolia_suspend(struct device *dev)
+{
+	int idx;
+	struct aeolia_xhci *axhci = dev_get_drvdata(dev);
+	struct xhci_hcd	*xhci;
+	int retval;
+	struct pci_dev		*pdev = to_pci_dev(dev);
+	
+	for (idx = 0; idx < NR_DEVICES; idx++) {
+		if(pdev->device != PCI_DEVICE_ID_SONY_AEOLIA_XHCI && idx == 1)
+			continue;
+		xhci = hcd_to_xhci(axhci->hcd[idx]);
+		retval = xhci_suspend(xhci, device_may_wakeup(dev));
+		if (retval < 0)
+			goto resume;
+	}
+	return 0;
+
+resume:
+	while (idx--) {
+		xhci = hcd_to_xhci(axhci->hcd[idx]);
+		xhci_resume(xhci, 0);
+	}
+	return retval;
+}
+
+static int xhci_aeolia_resume(struct device *dev)
+{
+	int idx;
+	struct aeolia_xhci *axhci = dev_get_drvdata(dev);
+	struct xhci_hcd	*xhci;
+	int retval;
+	struct pci_dev		*pdev = to_pci_dev(dev);
+
+	for (idx = 0; idx < NR_DEVICES; idx++) {
+ 		if(pdev->device != PCI_DEVICE_ID_SONY_AEOLIA_XHCI && idx == 1) 
+			continue;		
+		xhci = hcd_to_xhci(axhci->hcd[idx]);
+		retval = xhci_resume(xhci, 0);
+		if (retval < 0)
+			return retval;
+	}
+	return 0;
+}
+
+static const struct dev_pm_ops xhci_aeolia_pm_ops = {
+	SET_SYSTEM_SLEEP_PM_OPS(xhci_aeolia_suspend, xhci_aeolia_resume)
+};
+#endif
+
+/* pci driver glue; this is a "new style" PCI driver module */
+static struct pci_driver xhci_aeolia_driver = {
+	.name =		"xhci_aeolia",
+	.id_table =	pci_ids,
+
+	.probe =	xhci_aeolia_probe,
+	.remove =	xhci_aeolia_remove,
+	/* suspend and resume implemented later */
+
+	.shutdown = 	usb_hcd_pci_shutdown,
+#ifdef CONFIG_PM_SLEEP
+	.driver = {
+		.pm = &xhci_aeolia_pm_ops
+	},
+#endif
+};
+
+static int __init xhci_aeolia_init(void)
+{
+	xhci_init_driver(&xhci_aeolia_hc_driver, &xhci_aeolia_overrides);
+	return pci_register_driver(&xhci_aeolia_driver);
+}
+module_init(xhci_aeolia_init);
+
+static void __exit xhci_aeolia_exit(void)
+{
+	pci_unregister_driver(&xhci_aeolia_driver);
+}
+module_exit(xhci_aeolia_exit);
+
+MODULE_DESCRIPTION("xHCI Aeolia Host Controller Driver");
+MODULE_LICENSE("GPL");
