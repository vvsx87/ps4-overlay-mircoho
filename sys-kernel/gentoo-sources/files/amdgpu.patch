diff -ruN a/drivers/gpu/drm/amd/amdgpu/Makefile b/drivers/gpu/drm/amd/amdgpu/Makefile
--- a/drivers/gpu/drm/amd/amdgpu/Makefile	2022-10-13 07:15:21.294047186 +0200
+++ b/drivers/gpu/drm/amd/amdgpu/Makefile	2022-10-13 06:49:01.171130379 +0200
@@ -166,7 +166,7 @@
 amdgpu-$(CONFIG_VGA_SWITCHEROO) += amdgpu_atpx_handler.o
 amdgpu-$(CONFIG_ACPI) += amdgpu_acpi.o
 amdgpu-$(CONFIG_MMU_NOTIFIER) += amdgpu_mn.o
-
+amdgpu-$(CONFIG_X86_PS4) += ps4_bridge.o
 include $(FULL_AMD_PATH)/powerplay/Makefile
 
 amdgpu-y += $(AMD_POWERPLAY_FILES)
diff -ruN a/drivers/gpu/drm/amd/amdgpu/ps4_bridge.c b/drivers/gpu/drm/amd/amdgpu/ps4_bridge.c
--- a/drivers/gpu/drm/amd/amdgpu/ps4_bridge.c	1970-01-01 01:00:00.000000000 +0100
+++ b/drivers/gpu/drm/amd/amdgpu/ps4_bridge.c	2022-10-13 07:01:45.745158117 +0200
@@ -0,0 +1,758 @@
+/*
+ * Panasonic MN86471A DP->HDMI bridge driver (via PS4 Aeolia ICC interface)
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <asm/ps4.h>
+
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_edid.h>
+#include <drm/drmP.h>
+
+#include "amdgpu_mode.h"
+#include "atombios_dp.h"
+#include "ObjectID.h"
+
+#define CMD_READ	1, 1
+#define CMD_WRITE	2, 2
+#define CMD_MASK	2, 3
+#define CMD_DELAY	3, 1
+#define CMD_WAIT_SET	3, 2
+#define CMD_WAIT_CLEAR	3, 3
+
+#define TSYSCTRL 0x7005
+# define TSYSCTRL_HDMI BIT(7)
+
+#define TSRST 0x7006
+# define TSRST_AVCSRST BIT(0)
+# define TSRST_ENCSRST BIT(1)
+# define TSRST_FIFOSRST BIT(2)
+# define TSRST_CCSRST BIT(3)
+# define TSRST_HDCPSRST BIT(4)
+# define TSRST_AUDSRST BIT(6)
+# define TSRST_VIFSRST BIT(7)
+
+#define TMONREG 0x7008
+# define TMONREG_HPD BIT(3)
+
+#define TDPCMODE 0x7009
+
+
+#define UPDCTRL 0x7011
+# define UPDCTRL_ALLUPD BIT(7)
+# define UPDCTRL_AVIIUPD BIT(6)
+# define UPDCTRL_AUDIUPD BIT(5)
+# define UPDCTRL_CLKUPD BIT(4)
+# define UPDCTRL_HVSIUPD BIT(3)
+# define UPDCTRL_VIFUPD BIT(2)
+# define UPDCTRL_AUDUPD BIT(1)
+# define UPDCTRL_CSCUPD BIT(0)
+
+
+#define VINCNT 0x7040
+# define VINCNT_VIF_FILEN BIT(6)
+
+#define VMUTECNT 0x705f
+# define VMUTECNT_CCVMUTE BIT(7)
+# define VMUTECNT_DUMON BIT(6)
+# define VMUTECNT_LINEWIDTH_80 (0<<4)
+# define VMUTECNT_LINEWIDTH_90 (1<<4)
+# define VMUTECNT_LINEWIDTH_180 (2<<4)
+# define VMUTECNT_LINEWIDTH_360 (3<<4)
+# define VMUTECNT_VMUTE_MUTE_ASYNC 1
+# define VMUTECNT_VMUTE_MUTE_NORMAL 2
+# define VMUTECNT_VMUTE_MUTE_RAMPA 4
+# define VMUTECNT_VMUTE_MUTE_RAMPB 8
+# define VMUTECNT_VMUTE_MUTE_COLORBAR_RGB 10
+# define VMUTECNT_VMUTE_MUTE_TOGGLE 12
+# define VMUTECNT_VMUTE_MUTE_COLORBAR_YCBCR 14
+
+#define CSCMOD 0x70c0
+#define C420SET 0x70c2
+#define OUTWSET 0x70c3
+
+#define PKTENA 0x7202
+
+#define INFENA 0x7203
+# define INFENA_AVIEN BIT(6)
+
+#define AKESTA 0x7a84
+# define AKESTA_BUSY BIT(0)
+
+#define AKESRST 0x7a88
+
+#define HDCPEN 0x7a8b
+# define HDCPEN_NONE 0x00
+# define HDCPEN_ENC_EN 0x03
+# define HDCPEN_ENC_DIS 0x05
+
+#define PCI_DEVICE_ID_CUH_11XX 0x9920
+#define PCI_DEVICE_ID_CUH_12XX 0x9922
+#define PCI_DEVICE_ID_CUH_2XXX 0x9923
+#define PCI_DEVICE_ID_CUH_7XXX 0x9924
+
+struct i2c_cmd_hdr {
+	u8 major;
+	u8 length;
+	u8 minor;
+	u8 count;
+} __packed;
+
+struct i2c_cmdqueue {
+	struct {
+		u8 code;
+		u16 length;
+		u8 count;
+		u8 cmdbuf[0x7ec];
+	} __packed req;
+	struct {
+		u8 res1, res2;
+		u8 unk1, unk2;
+		u8 count;
+		u8 databuf[0x7eb];
+	} __packed reply;
+
+	u8 *p;
+	struct i2c_cmd_hdr *cmd;
+};
+
+struct ps4_bridge {
+	struct drm_connector *connector;
+	struct drm_encoder *encoder;
+	struct drm_bridge bridge;
+	struct i2c_cmdqueue cq;
+	struct mutex mutex;
+
+	int mode;
+};
+
+/* this should really be taken care of by the connector, but that is currently
+ * contained/owned by radeon_connector so just use a global for now */
+static struct ps4_bridge g_bridge = {
+	.mutex = __MUTEX_INITIALIZER(g_bridge.mutex)
+};
+
+static void cq_init(struct i2c_cmdqueue *q, u8 code)
+{
+	q->req.code = code;
+	q->req.count = 0;
+	q->p = q->req.cmdbuf;
+	q->cmd = NULL;
+}
+
+static void cq_cmd(struct i2c_cmdqueue *q, u8 major, u8 minor)
+{
+	if (!q->cmd || q->cmd->major != major || q->cmd->minor != minor) {
+		if (q->cmd)
+			q->cmd->length = q->p - (u8 *)q->cmd;
+		q->cmd = (struct i2c_cmd_hdr *)q->p;
+		q->cmd->major = major;
+		q->cmd->minor = minor;
+		q->cmd->length = 0;
+		q->cmd->count = 1;
+		q->req.count += 1;
+		q->p += sizeof(*q->cmd);
+	} else {
+		q->cmd->count += 1;
+	}
+}
+
+static int cq_exec(struct i2c_cmdqueue *q)
+{
+	int res;
+
+	if (!q->cmd)
+		return 0;
+
+	q->cmd->length = q->p - (u8 *)q->cmd;
+	q->req.length = q->p - (u8 *)&q->req;
+
+	res = apcie_icc_cmd(0x10, 0, &q->req, q->req.length,
+		      &q->reply, sizeof(q->reply));
+
+	if (res < 5) {
+		DRM_ERROR("icc i2c commandqueue failed: %d\n", res);
+		return -EIO;
+	}
+	if (q->reply.res1 != 0 || q->reply.res2) {
+		DRM_ERROR("icc i2c commandqueue failed: %d, %d\n",
+			  q->reply.res1, q->reply.res2);
+		return -EIO;
+	}
+
+	return res;
+}
+
+static void cq_read(struct i2c_cmdqueue *q, u16 addr, u8 count)
+{
+	cq_cmd(q, CMD_READ);
+	*q->p++ = count;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	*q->p++ = 0;
+}
+
+static void cq_writereg(struct i2c_cmdqueue *q, u16 addr, u8 data)
+{
+	cq_cmd(q, CMD_WRITE);
+	*q->p++ = 1;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	*q->p++ = data;
+}
+
+#if 0
+static void cq_write(struct i2c_cmdqueue *q, u16 addr, u8 *data, u8 count)
+{
+	cq_cmd(q, CMD_WRITE);
+	*q->p++ = count;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	while (count--)
+		*q->p++ = *data++;
+}
+#endif
+
+static void cq_mask(struct i2c_cmdqueue *q, u16 addr, u8 value, u8 mask)
+{
+	cq_cmd(q, CMD_MASK);
+	*q->p++ = 1;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	*q->p++ = value;
+	*q->p++ = mask;
+}
+
+#if 1
+static void cq_delay(struct i2c_cmdqueue *q, u16 time)
+{
+	cq_cmd(q, CMD_DELAY);
+	*q->p++ = 0;
+	*q->p++ = time & 0xff;
+	*q->p++ = time>>8;
+	*q->p++ = 0;
+}
+#endif
+
+static void cq_wait_set(struct i2c_cmdqueue *q, u16 addr, u8 mask)
+{
+	cq_cmd(q, CMD_WAIT_SET);
+	*q->p++ = 0;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	*q->p++ = mask;
+}
+
+static void cq_wait_clear(struct i2c_cmdqueue *q, u16 addr, u8 mask)
+{
+	cq_cmd(q, CMD_WAIT_CLEAR);
+	*q->p++ = 0;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	*q->p++ = mask;
+}
+
+static inline struct ps4_bridge *
+		bridge_to_ps4_bridge(struct drm_bridge *bridge)
+{
+	return container_of(bridge, struct ps4_bridge, bridge);
+}
+
+static void ps4_bridge_mode_set(struct drm_bridge *bridge,
+			      struct drm_display_mode *mode,
+			      struct drm_display_mode *adjusted_mode)
+{
+	struct ps4_bridge *mn_bridge = bridge_to_ps4_bridge(bridge);
+
+	/* This gets called before pre_enable/enable, so we just stash
+	 * the vic ID for later */
+	mn_bridge->mode = drm_match_cea_mode(adjusted_mode);
+	DRM_DEBUG_KMS("vic mode: %d\n", mn_bridge->mode);
+	if (!mn_bridge->mode) {
+		DRM_ERROR("attempted to set non-CEA mode\n");
+	}
+}
+
+static void ps4_bridge_pre_enable(struct drm_bridge *bridge)
+{
+	struct ps4_bridge *mn_bridge = bridge_to_ps4_bridge(bridge);
+	DRM_DEBUG_KMS("ps4_bridge_pre_enable\n");
+	DRM_DEBUG("Enable ps4_bridge_pre_enable\n");
+	mutex_lock(&mn_bridge->mutex);
+	cq_init(&mn_bridge->cq, 4);
+
+#if 0
+	/* No idea. DP stuff probably. This borks for some reason. Meh. */
+	cq_writereg(&mn_bridge->cq, 0x7657,0xff);
+	cq_writereg(&mn_bridge->cq, 0x76a5,0x80);
+	cq_writereg(&mn_bridge->cq, 0x76a6,0x04);
+	cq_writereg(&mn_bridge->cq, 0x7601,0x0a);
+	cq_writereg(&mn_bridge->cq, 0x7602,0x84);
+	cq_writereg(&mn_bridge->cq, 0x7603,0x00);
+	cq_writereg(&mn_bridge->cq, 0x76a8,0x09);
+	cq_writereg(&mn_bridge->cq, 0x76ae,0xd1);
+	cq_writereg(&mn_bridge->cq, 0x76af,0x50);
+	cq_writereg(&mn_bridge->cq, 0x76b0,0x70);
+	cq_writereg(&mn_bridge->cq, 0x76b1,0xb0);
+	cq_writereg(&mn_bridge->cq, 0x76b2,0xf0);
+	cq_writereg(&mn_bridge->cq, 0x76db,0x00);
+	cq_writereg(&mn_bridge->cq, 0x76dc,0x64);
+	cq_writereg(&mn_bridge->cq, 0x76dd,0x22);
+	cq_writereg(&mn_bridge->cq, 0x76e4,0x00);
+	cq_writereg(&mn_bridge->cq, 0x76e6,0x1e); /* 0 for (DP?) scramble off */
+	cq_writereg(&mn_bridge->cq, 0x7670,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7671,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7672,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7673,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7668,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7669,0xff);
+	cq_writereg(&mn_bridge->cq, 0x766a,0xff);
+	cq_writereg(&mn_bridge->cq, 0x766b,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7655,0x04);
+	cq_writereg(&mn_bridge->cq, 0x7007,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7098,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7099,0x00);
+	cq_writereg(&mn_bridge->cq, 0x709a,0x0f);
+	cq_writereg(&mn_bridge->cq, 0x709b,0x00);
+	cq_writereg(&mn_bridge->cq, 0x709c,0x50);
+	cq_writereg(&mn_bridge->cq, 0x709d,0x00);
+	cq_writereg(&mn_bridge->cq, 0x709e,0x00);
+	cq_writereg(&mn_bridge->cq, 0x709f,0xd0);
+	cq_writereg(&mn_bridge->cq, 0x7a9c,0x2e);
+	cq_writereg(&mn_bridge->cq, 0x7021,0x04);
+	cq_writereg(&mn_bridge->cq, 0x7028,0x00);
+	cq_writereg(&mn_bridge->cq, 0x7030,0xa3);
+	cq_writereg(&mn_bridge->cq, 0x7016,0x04);
+#endif
+
+	/* Disable InfoFrames */
+	cq_writereg(&mn_bridge->cq, INFENA, 0x00);
+	/* Reset HDCP */
+	cq_writereg(&mn_bridge->cq, TSRST, TSRST_ENCSRST | TSRST_HDCPSRST);
+	/* Disable HDCP flag */
+	cq_writereg(&mn_bridge->cq, TSRST, HDCPEN_ENC_DIS);
+	/* HDCP AKE reset */
+	cq_writereg(&mn_bridge->cq, AKESRST, 0xff);
+	/* Wait AKE busy */
+	cq_wait_clear(&mn_bridge->cq, AKESTA, AKESTA_BUSY);
+
+	if (cq_exec(&mn_bridge->cq) < 0) {
+		DRM_ERROR("failed to run pre-enable sequence");
+	}
+	mutex_unlock(&mn_bridge->mutex);
+}
+
+static void ps4_bridge_enable(struct drm_bridge *bridge)
+{
+	struct ps4_bridge *mn_bridge = bridge_to_ps4_bridge(bridge);
+	struct drm_connector *connector = mn_bridge->connector;
+	struct drm_device *dev = connector->dev;
+	struct pci_dev *pdev = dev->pdev;
+	u8 dp[3];
+	DRM_DEBUG("Enable PS4_BRIDGE_ENABLE\n");
+	if (!mn_bridge->mode) {
+		DRM_ERROR("mode not available\n");
+		return;
+	}
+
+	if(pdev->vendor != PCI_VENDOR_ID_ATI) {
+		DRM_ERROR("Invalid vendor: %04x", pdev->vendor);
+		return;
+	}
+
+	DRM_DEBUG_KMS("ps4_bridge_enable (mode: %d)\n", mn_bridge->mode);
+
+	/* Here come the dragons */
+
+	if(pdev->device == PCI_DEVICE_ID_CUH_11XX)
+	{
+		/* Panasonic MN86471A */
+		mutex_lock(&mn_bridge->mutex);
+		cq_init(&mn_bridge->cq, 4);
+
+		/* Read DisplayPort status (?) */
+		cq_read(&mn_bridge->cq, 0x76e1, 3);
+		if (cq_exec(&mn_bridge->cq) < 11) {
+			mutex_unlock(&mn_bridge->mutex);
+			DRM_ERROR("could not read DP status");
+		return;
+		}
+		memcpy(dp, &mn_bridge->cq.reply.databuf[3], 3);
+
+		cq_init(&mn_bridge->cq, 4);
+
+		/* Wait for DP lane status */
+		cq_wait_set(&mn_bridge->cq, 0x761e, 0x77);
+		cq_wait_set(&mn_bridge->cq, 0x761f, 0x77);
+		/* Wait for ?? */
+		cq_wait_set(&mn_bridge->cq, 0x7669, 0x01);
+		cq_writereg(&mn_bridge->cq, 0x76d9, (dp[0] & 0x1f) | (dp[0] << 5));
+		cq_writereg(&mn_bridge->cq, 0x76da, (dp[1] & 0x7c) | ((dp[0] >> 3) & 3) | ((dp[1] << 5) & 0x80));
+		cq_writereg(&mn_bridge->cq, 0x76db, 0x80 | ((dp[1] >> 3) & 0xf));
+		cq_writereg(&mn_bridge->cq, 0x76e4, 0x01);
+		cq_writereg(&mn_bridge->cq, TSYSCTRL, TSYSCTRL_HDMI);
+		cq_writereg(&mn_bridge->cq, VINCNT, VINCNT_VIF_FILEN);
+		cq_writereg(&mn_bridge->cq, 0x7071, 0);
+		cq_writereg(&mn_bridge->cq, 0x7062, mn_bridge->mode);
+		cq_writereg(&mn_bridge->cq, 0x765a, 0);
+		cq_writereg(&mn_bridge->cq, 0x7062, mn_bridge->mode | 0x80);
+		cq_writereg(&mn_bridge->cq, 0x7215, 0x28); /* aspect */
+		cq_writereg(&mn_bridge->cq, 0x7217, mn_bridge->mode);
+		cq_writereg(&mn_bridge->cq, 0x7218, 0);
+		cq_writereg(&mn_bridge->cq, CSCMOD, 0xdc);
+		cq_writereg(&mn_bridge->cq, C420SET, 0xaa);
+		cq_writereg(&mn_bridge->cq, TDPCMODE, 0x4a);
+		cq_writereg(&mn_bridge->cq, OUTWSET, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x70c4, 0x08);
+		cq_writereg(&mn_bridge->cq, 0x70c5, 0x08);
+		cq_writereg(&mn_bridge->cq, 0x7096, 0xff);
+		cq_writereg(&mn_bridge->cq, 0x7027, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7020, 0x20);
+		cq_writereg(&mn_bridge->cq, 0x700b, 0x01);
+		cq_writereg(&mn_bridge->cq, PKTENA, 0x20);
+		cq_writereg(&mn_bridge->cq, 0x7096, 0xff);
+		cq_writereg(&mn_bridge->cq, INFENA, INFENA_AVIEN);
+		cq_writereg(&mn_bridge->cq, UPDCTRL, UPDCTRL_ALLUPD | UPDCTRL_AVIIUPD |
+						     UPDCTRL_CLKUPD | UPDCTRL_VIFUPD |
+						     UPDCTRL_CSCUPD);
+		cq_wait_set(&mn_bridge->cq, 0x7096, 0x80);
+
+		cq_mask(&mn_bridge->cq, 0x7216, 0x00, 0x80);
+		cq_writereg(&mn_bridge->cq, 0x7218, 0x00);
+
+		cq_writereg(&mn_bridge->cq, 0x7096, 0xff);
+		cq_writereg(&mn_bridge->cq, VMUTECNT, VMUTECNT_LINEWIDTH_90 | VMUTECNT_VMUTE_MUTE_NORMAL);
+		cq_writereg(&mn_bridge->cq, 0x7016, 0x04);
+		cq_writereg(&mn_bridge->cq, 0x7a88, 0xff);
+		cq_writereg(&mn_bridge->cq, 0x7a83, 0x88);
+		cq_writereg(&mn_bridge->cq, 0x7204, 0x40);
+
+		cq_wait_set(&mn_bridge->cq, 0x7096, 0x80);
+
+		cq_writereg(&mn_bridge->cq, 0x7006, 0x02);
+		cq_writereg(&mn_bridge->cq, 0x7020, 0x21);
+		cq_writereg(&mn_bridge->cq, 0x7a8b, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7020, 0x21);
+
+		cq_writereg(&mn_bridge->cq, VMUTECNT, VMUTECNT_LINEWIDTH_90);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+			DRM_ERROR("Failed to configure ps4-bridge (MN86471A) mode\n");
+		}
+		#if 1
+		// preinit
+		cq_init(&mn_bridge->cq, 4);
+		cq_writereg(&mn_bridge->cq,0x70b3, 0x00);
+		cq_writereg(&mn_bridge->cq,0x70b7, 0x0b);
+		cq_writereg(&mn_bridge->cq,0x70a8, 0x24);
+
+		cq_mask(&mn_bridge->cq,0x70b9, 0x06, 0x06);
+		cq_mask(&mn_bridge->cq,0x70b6, 0x02, 0x0f);
+		cq_mask(&mn_bridge->cq,0x70ba, 0x40, 0x70);
+		cq_mask(&mn_bridge->cq,0x70b2, 0x20, 0xe0);
+		cq_mask(&mn_bridge->cq,0x7257, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b0, 0x01, 0x21);
+		cq_mask(&mn_bridge->cq,0x70ba, 0x00, 0x88);
+		cq_mask(&mn_bridge->cq,0x70b9, 0x01, 0x01);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+			DRM_ERROR("failed to run enable MN86471A hdmi audio seq. 0");
+		}
+
+		cq_init(&mn_bridge->cq, 4);
+		cq_writereg(&mn_bridge->cq,0x7ed8, 0x01);
+
+		cq_mask(&mn_bridge->cq,0x70b4, 0x00, 0x3e);
+		cq_mask(&mn_bridge->cq,0x70b5, 0x79, 0xff);
+		cq_mask(&mn_bridge->cq,0x70ab, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b6, 0x02, 0x3f);
+		cq_mask(&mn_bridge->cq,0x70b7, 0x0b, 0x0f);
+		cq_mask(&mn_bridge->cq,0x70ac, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70bd, 0x00, 0xff);
+
+		cq_writereg(&mn_bridge->cq, 0x7204, 0x10);
+		cq_writereg(&mn_bridge->cq,0x7011, 0xa2);
+
+		cq_wait_set(&mn_bridge->cq,0x7096, 0x80);
+		cq_writereg(&mn_bridge->cq,0x7096, 0xff);
+
+		cq_mask(&mn_bridge->cq,0x7203, 0x10, 0x10);
+		cq_writereg(&mn_bridge->cq,0x70b1, 0xc0);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+			DRM_ERROR("failed to run enable hdmi MN86471A audio seq. 1");
+		}
+		#endif
+		mutex_unlock(&mn_bridge->mutex);
+	}
+	else
+	{
+		/* Panasonic MN864729 */
+		mutex_lock(&mn_bridge->mutex);
+		cq_init(&mn_bridge->cq, 4);
+		cq_mask(&mn_bridge->cq, 0x6005, 0x01, 0x01);
+		cq_writereg(&mn_bridge->cq, 0x6a03, 0x47);
+
+		/* Wait for DP lane status */
+		cq_wait_set(&mn_bridge->cq, 0x60f8, 0xff);
+		cq_wait_set(&mn_bridge->cq, 0x60f9, 0x01);
+		cq_writereg(&mn_bridge->cq, 0x6a01, 0x4d);
+		cq_wait_set(&mn_bridge->cq, 0x60f9, 0x1a);
+
+		cq_mask(&mn_bridge->cq, 0x1e00, 0x00, 0x21);
+		cq_mask(&mn_bridge->cq, 0x1e02, 0x00, 0x70);
+		// 03 08 01 01 00  2c 01 00
+		cq_delay(&mn_bridge->cq, 0x012c);
+		cq_writereg(&mn_bridge->cq, 0x6020, 0x00);
+		cq_delay(&mn_bridge->cq, 0x0032);
+		cq_writereg(&mn_bridge->cq, 0x7402, 0x1c);
+		cq_writereg(&mn_bridge->cq, 0x6020, 0x04);
+		cq_writereg(&mn_bridge->cq, TSYSCTRL, TSYSCTRL_HDMI);
+		cq_writereg(&mn_bridge->cq, 0x10c7, 0x38);
+		cq_writereg(&mn_bridge->cq, 0x1e02, 0x88);
+		cq_writereg(&mn_bridge->cq, 0x1e00, 0x66);
+		cq_writereg(&mn_bridge->cq, 0x100c, 0x01);
+		cq_writereg(&mn_bridge->cq, TSYSCTRL, TSYSCTRL_HDMI);
+
+		cq_writereg(&mn_bridge->cq, 0x7009, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7040, 0x42);
+		cq_writereg(&mn_bridge->cq, 0x7225, 0x28);
+		cq_writereg(&mn_bridge->cq, 0x7227, mn_bridge->mode);
+		cq_writereg(&mn_bridge->cq, 0x7228, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7070, mn_bridge->mode);
+		cq_writereg(&mn_bridge->cq, 0x7071, mn_bridge->mode | 0x80);
+		cq_writereg(&mn_bridge->cq, 0x7072, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7073, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7074, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7075, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x70c4, 0x0a);
+		cq_writereg(&mn_bridge->cq, 0x70c5, 0x0a);
+		cq_writereg(&mn_bridge->cq, 0x70c2, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x70fe, 0x12);
+		cq_writereg(&mn_bridge->cq, 0x70c3, 0x10);
+
+		if(pdev->device == PCI_DEVICE_ID_CUH_12XX) {
+			/* newer ps4 phats need here 0x03 idk why. */
+			cq_writereg(&mn_bridge->cq, 0x10c5, 0x03);
+		} else {
+			cq_writereg(&mn_bridge->cq, 0x10c5, 0x00);
+		}
+
+		cq_writereg(&mn_bridge->cq, 0x10f6, 0xff);
+		cq_writereg(&mn_bridge->cq, 0x7202, 0x20);
+		cq_writereg(&mn_bridge->cq, 0x7203, 0x60);
+		cq_writereg(&mn_bridge->cq, 0x7011, 0xd5);
+		//cq_writereg(&mn_bridge->cq, 0x7a00, 0x0e);
+
+		cq_wait_set(&mn_bridge->cq, 0x10f6, 0x80);
+		cq_mask(&mn_bridge->cq, 0x7226, 0x00, 0x80);
+		cq_mask(&mn_bridge->cq, 0x7228, 0x00, 0xFF);
+		cq_delay(&mn_bridge->cq, 0x012c);
+		cq_writereg(&mn_bridge->cq, 0x7204, 0x40);
+		cq_wait_clear(&mn_bridge->cq, 0x7204, 0x40);
+		cq_writereg(&mn_bridge->cq, 0x7a8b, 0x05);
+		cq_mask(&mn_bridge->cq, 0x1e02, 0x70, 0x70);
+		cq_mask(&mn_bridge->cq, 0x1034, 0x02, 0x02);
+		cq_mask(&mn_bridge->cq, 0x1e00, 0x01, 0x01);
+		cq_writereg(&mn_bridge->cq, VMUTECNT, VMUTECNT_LINEWIDTH_90);
+		cq_writereg(&mn_bridge->cq, HDCPEN, 0x00);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+			DRM_ERROR("Failed to configure ps4-bridge (MN864729) mode\n");
+		}
+		#if 1
+		// AUDIO preinit
+		cq_init(&mn_bridge->cq, 4);
+		cq_writereg(&mn_bridge->cq,0x70aa, 0x00);
+		cq_writereg(&mn_bridge->cq,0x70af, 0x07);
+		cq_writereg(&mn_bridge->cq,0x70a9, 0x5a);
+
+		cq_mask(&mn_bridge->cq,0x70af, 0x06, 0x06);
+		cq_mask(&mn_bridge->cq,0x70af, 0x02, 0x0f);
+		cq_mask(&mn_bridge->cq,0x70b3, 0x02, 0x0f);
+		cq_mask(&mn_bridge->cq,0x70ae, 0x80, 0xe0);
+		cq_mask(&mn_bridge->cq,0x70ae, 0x01, 0x07);
+		cq_mask(&mn_bridge->cq,0x70ac, 0x01, 0x21);
+		cq_mask(&mn_bridge->cq,0x70ab, 0x80, 0x88);
+		cq_mask(&mn_bridge->cq,0x70a9, 0x01, 0x01);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+				DRM_ERROR("failed to run enable hdmi audio seq. 0");
+		}
+
+		cq_init(&mn_bridge->cq, 4);
+		cq_writereg(&mn_bridge->cq,0x70b0, 0x01);
+		cq_mask(&mn_bridge->cq,0x70b0, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b1, 0x79, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b2, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b3, 0x02, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b4, 0x0b, 0x0f);
+		cq_mask(&mn_bridge->cq,0x70b5, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b6, 0x00, 0xff);
+		cq_writereg(&mn_bridge->cq,0x10f6, 0xff);
+		cq_writereg(&mn_bridge->cq,0x7011, 0xa2);
+		cq_wait_set(&mn_bridge->cq,0x10f6, 0xa2);
+		cq_mask(&mn_bridge->cq,0x7267, 0x00, 0xff);
+		cq_writereg(&mn_bridge->cq,0x7204, 0x10);
+		cq_wait_clear(&mn_bridge->cq,0x7204, 0x10);
+		cq_writereg(&mn_bridge->cq,0x10f6, 0xff);
+		cq_mask(&mn_bridge->cq,0x7203, 0x10, 0x10);
+		cq_writereg(&mn_bridge->cq,0x70a8, 0xc0);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+				DRM_ERROR("failed to run enable hdmi audio seq. 1");
+		}
+		#endif
+		mutex_unlock(&mn_bridge->mutex);
+	}
+
+}
+
+static void ps4_bridge_disable(struct drm_bridge *bridge)
+{
+	struct ps4_bridge *mn_bridge = bridge_to_ps4_bridge(bridge);
+	DRM_DEBUG_KMS("ps4_bridge_disable\n");
+
+	mutex_lock(&mn_bridge->mutex);
+	cq_init(&mn_bridge->cq, 4);
+	cq_writereg(&mn_bridge->cq, VMUTECNT, VMUTECNT_LINEWIDTH_90 | VMUTECNT_VMUTE_MUTE_NORMAL);
+	cq_writereg(&mn_bridge->cq, INFENA, 0x00);
+	if (cq_exec(&mn_bridge->cq) < 0) {
+		DRM_ERROR("Failed to disable bridge\n");
+	}
+	mutex_unlock(&mn_bridge->mutex);
+}
+
+static void ps4_bridge_post_disable(struct drm_bridge *bridge)
+{
+	/* struct ps4_bridge *mn_bridge = bridge_to_mn864729(bridge); */
+	DRM_DEBUG_KMS("ps4_bridge_post_disable\n");
+}
+
+/* Hardcoded modes, since we don't really know how to do custom modes yet.
+ * Other CEA modes *should* work (and are allowed if externally added) */
+
+/* 1 - 640x480@60Hz */
+static const struct drm_display_mode mode_480p = {
+	DRM_MODE("640x480", DRM_MODE_TYPE_DRIVER, 25175, 640, 656,
+		 752, 800, 0, 480, 490, 492, 525, 0,
+		 DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	.vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3
+};
+/* 4 - 1280x720@60Hz */
+static const struct drm_display_mode mode_720p = {
+	DRM_MODE("1280x720", DRM_MODE_TYPE_DRIVER, 74250, 1280, 1390,
+		 1430, 1650, 0, 720, 725, 730, 750, 0,
+		 DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9
+};
+/* 16 - 1920x1080@60Hz */
+static const struct drm_display_mode mode_1080p = {
+	DRM_MODE("1920x1080", DRM_MODE_TYPE_DRIVER, 148500, 1920, 2008,
+		 2052, 2200, 0, 1080, 1084, 1089, 1125, 0,
+		 DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9
+};
+
+int ps4_bridge_get_modes(struct drm_connector *connector)
+{
+	struct drm_device *dev = connector->dev;
+	struct drm_display_mode *newmode;
+	DRM_DEBUG_KMS("ps4_bridge_get_modes\n");
+
+	newmode = drm_mode_duplicate(dev, &mode_1080p);
+	drm_mode_probed_add(connector, newmode);
+
+	//newmode = drm_mode_duplicate(dev, &mode_720p);
+	//drm_mode_probed_add(connector, newmode);
+	//newmode = drm_mode_duplicate(dev, &mode_480p);
+	//drm_mode_probed_add(connector, newmode);
+
+	drm_connector_update_edid_property(connector, NULL);
+
+	return 0;
+}
+
+enum drm_connector_status ps4_bridge_detect(struct drm_connector *connector,
+		bool force)
+{
+	struct ps4_bridge *mn_bridge = &g_bridge;
+	u8 reg;
+
+	struct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);
+	struct amdgpu_connector_atom_dig *amdgpu_dig_connector = amdgpu_connector->con_priv;
+
+	amdgpu_dig_connector->dp_sink_type = CONNECTOR_OBJECT_ID_DISPLAYPORT;
+	amdgpu_atombios_dp_get_dpcd(amdgpu_connector);
+
+	mutex_lock(&mn_bridge->mutex);
+	cq_init(&mn_bridge->cq, 4);
+	cq_read(&mn_bridge->cq, TMONREG, 1);
+	if (cq_exec(&mn_bridge->cq) < 9) {
+		mutex_unlock(&mn_bridge->mutex);
+		DRM_ERROR("could not read TMONREG");
+		return connector_status_disconnected;
+	}
+	reg = mn_bridge->cq.reply.databuf[3];
+	mutex_unlock(&mn_bridge->mutex);
+
+	DRM_DEBUG_KMS("TMONREG=0x%02x\n", reg);
+
+	if (reg & TMONREG_HPD)
+		return connector_status_connected;
+	else
+		return connector_status_disconnected;
+}
+
+int ps4_bridge_mode_valid(struct drm_connector *connector,
+				  struct drm_display_mode *mode)
+{
+	int vic = drm_match_cea_mode(mode);
+
+	/* Allow anything that we can match up to a VIC (CEA modes) */
+	if (!vic || (vic != 16 && vic != 4)) {
+		return MODE_BAD;
+	}
+
+	return MODE_OK;
+}
+
+static int ps4_bridge_attach(struct drm_bridge *bridge)
+{
+	/* struct ps4_bridge *mn_bridge = bridge_to_ps4_bridge(bridge); */
+
+	return 0;
+}
+
+static struct drm_bridge_funcs ps4_bridge_funcs = {
+	.pre_enable = ps4_bridge_pre_enable,
+	.enable = ps4_bridge_enable,
+	.disable = ps4_bridge_disable,
+	.post_disable = ps4_bridge_post_disable,
+	.attach = ps4_bridge_attach,
+	.mode_set = ps4_bridge_mode_set
+};
+
+int ps4_bridge_register(struct drm_connector *connector,
+			     struct drm_encoder *encoder)
+{
+	int ret;
+	struct ps4_bridge *mn_bridge = &g_bridge;
+
+	mn_bridge->encoder = encoder;
+	mn_bridge->connector = connector;
+	mn_bridge->bridge.funcs = &ps4_bridge_funcs;
+	ret = drm_bridge_attach(mn_bridge->encoder, &mn_bridge->bridge, NULL);
+	if (ret) {
+		DRM_ERROR("Failed to initialize bridge with drm\n");
+		return -EINVAL;
+	}
+
+	encoder->bridge = &mn_bridge->bridge;
+
+	return 0;
+}
diff -ruN a/drivers/gpu/drm/amd/include/amd_shared.h b/drivers/gpu/drm/amd/include/amd_shared.h
--- a/drivers/gpu/drm/amd/include/amd_shared.h	2022-10-13 07:15:21.304047429 +0200
+++ b/drivers/gpu/drm/amd/include/amd_shared.h	2022-10-13 06:49:01.171130379 +0200
@@ -27,7 +27,6 @@
 
 
 #define AMD_MAX_USEC_TIMEOUT		200000  /* 200 ms */
-
 /*
  * Chip flags
  */
diff -ruN a/drivers/gpu/drm/amd/include/asic_reg/gmc/gmc_7_1_d.h b/drivers/gpu/drm/amd/include/asic_reg/gmc/gmc_7_1_d.h
--- a/drivers/gpu/drm/amd/include/asic_reg/gmc/gmc_7_1_d.h	2022-10-13 07:15:21.347048474 +0200
+++ b/drivers/gpu/drm/amd/include/asic_reg/gmc/gmc_7_1_d.h	2022-10-13 06:49:01.171130379 +0200
@@ -589,8 +589,24 @@
 #define mmVM_CONTEXT13_PAGE_TABLE_BASE_ADDR                                     0x513
 #define mmVM_CONTEXT14_PAGE_TABLE_BASE_ADDR                                     0x514
 #define mmVM_CONTEXT15_PAGE_TABLE_BASE_ADDR                                     0x515
+#define mmVM_CONTEXT8_PAGE_TABLE_START_ADDR                                     0x516
+#define mmVM_CONTEXT9_PAGE_TABLE_START_ADDR                                     0x517
+#define mmVM_CONTEXT10_PAGE_TABLE_START_ADDR                                    0x518
+#define mmVM_CONTEXT11_PAGE_TABLE_START_ADDR                                    0x519
+#define mmVM_CONTEXT12_PAGE_TABLE_START_ADDR                                    0x51a
+#define mmVM_CONTEXT13_PAGE_TABLE_START_ADDR                                    0x51b
+#define mmVM_CONTEXT14_PAGE_TABLE_START_ADDR                                    0x51c
+#define mmVM_CONTEXT15_PAGE_TABLE_START_ADDR                                    0x51d
 #define mmVM_INVALIDATE_REQUEST                                                 0x51e
 #define mmVM_INVALIDATE_RESPONSE                                                0x51f
+#define mmVM_CONTEXT8_PAGE_TABLE_END_ADDR                                       0x524
+#define mmVM_CONTEXT9_PAGE_TABLE_END_ADDR                                       0x525
+#define mmVM_CONTEXT10_PAGE_TABLE_END_ADDR                                      0x526
+#define mmVM_CONTEXT11_PAGE_TABLE_END_ADDR                                      0x527
+#define mmVM_CONTEXT12_PAGE_TABLE_END_ADDR                                      0x528
+#define mmVM_CONTEXT13_PAGE_TABLE_END_ADDR                                      0x529
+#define mmVM_CONTEXT14_PAGE_TABLE_END_ADDR                                      0x52a
+#define mmVM_CONTEXT15_PAGE_TABLE_END_ADDR                                      0x52b
 #define mmVM_PRT_APERTURE0_LOW_ADDR                                             0x52c
 #define mmVM_PRT_APERTURE1_LOW_ADDR                                             0x52d
 #define mmVM_PRT_APERTURE2_LOW_ADDR                                             0x52e
@@ -620,8 +636,20 @@
 #define mmVM_CONTEXT7_PAGE_TABLE_BASE_ADDR                                      0x556
 #define mmVM_CONTEXT0_PAGE_TABLE_START_ADDR                                     0x557
 #define mmVM_CONTEXT1_PAGE_TABLE_START_ADDR                                     0x558
+#define mmVM_CONTEXT2_PAGE_TABLE_START_ADDR                                     0x559
+#define mmVM_CONTEXT3_PAGE_TABLE_START_ADDR                                     0x55a
+#define mmVM_CONTEXT4_PAGE_TABLE_START_ADDR                                     0x55b
+#define mmVM_CONTEXT5_PAGE_TABLE_START_ADDR                                     0x55c
+#define mmVM_CONTEXT6_PAGE_TABLE_START_ADDR                                     0x55d
+#define mmVM_CONTEXT7_PAGE_TABLE_START_ADDR                                     0x55e
 #define mmVM_CONTEXT0_PAGE_TABLE_END_ADDR                                       0x55f
 #define mmVM_CONTEXT1_PAGE_TABLE_END_ADDR                                       0x560
+#define mmVM_CONTEXT2_PAGE_TABLE_END_ADDR                                       0x561
+#define mmVM_CONTEXT3_PAGE_TABLE_END_ADDR                                       0x562
+#define mmVM_CONTEXT4_PAGE_TABLE_END_ADDR                                       0x563
+#define mmVM_CONTEXT5_PAGE_TABLE_END_ADDR                                       0x564
+#define mmVM_CONTEXT6_PAGE_TABLE_END_ADDR                                       0x565
+#define mmVM_CONTEXT7_PAGE_TABLE_END_ADDR                                       0x566
 #define mmVM_DEBUG                                                              0x56f
 #define mmVM_L2_CG                                                              0x570
 #define mmVM_L2_BANK_SELECT_MASKA                                               0x572
diff -ruN a/drivers/gpu/drm/amd/amdgpu/amdgpu.h b/drivers/gpu/drm/amd/amdgpu/amdgpu.h
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu.h	2022-10-13 07:15:21.299047307 +0200
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu.h	2022-10-13 06:49:01.168130302 +0200
@@ -181,7 +181,8 @@
 /* max cursor sizes (in pixels) */
 #define CIK_CURSOR_WIDTH 128
 #define CIK_CURSOR_HEIGHT 128
-
+#define LVP_CURSOR_WIDTH 64
+#define LVP_CURSOR_HEIGHT 64
 struct amdgpu_device;
 struct amdgpu_ib;
 struct amdgpu_cs_parser;
diff -ruN a/drivers/gpu/drm/amd/amdgpu/amdgpu_ib.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_ib.c
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ib.c	2022-10-13 07:15:21.293047162 +0200
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ib.c	2022-10-13 06:49:01.168130302 +0200
@@ -343,7 +343,7 @@
 		tmo_gfx = 8 * AMDGPU_IB_TEST_TIMEOUT;
 	}
 
-	for (i = 0; i < AMDGPU_MAX_RINGS; ++i) {
+	for (i = 0; i < 1; ++i) {
 		struct amdgpu_ring *ring = adev->rings[i];
 		long tmo;
 
diff -ruN a/drivers/gpu/drm/amd/amdgpu/amdgpu_ih.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_ih.c
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ih.c	2022-10-13 07:15:21.294047186 +0200
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ih.c	2022-10-13 06:49:01.168130302 +0200
@@ -161,7 +161,7 @@
 	if (atomic_xchg(&adev->irq.ih.lock, 1))
 		return IRQ_NONE;
 
-	DRM_DEBUG("%s: rptr %d, wptr %d\n", __func__, adev->irq.ih.rptr, wptr);
+	//DRM_DEBUG("%s: rptr %d, wptr %d\n", __func__, adev->irq.ih.rptr, wptr);
 
 	/* Order reading of wptr vs. reading of IH ring data */
 	rmb();
diff -ruN a/drivers/gpu/drm/amd/amdgpu/amdgpu_irq.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_irq.c
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_irq.c	2022-10-13 07:15:21.299047307 +0200
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_irq.c	2022-10-13 06:49:01.168130302 +0200
@@ -388,9 +388,13 @@
 
 		src = adev->irq.client[client_id].sources[src_id];
 		if (!src) {
-			DRM_DEBUG("Unhandled interrupt src_id: %d\n", src_id);
+			//DRM_DEBUG("Unhandled interrupt src_id: %d\n", src_id);
 			return;
 		}
+		else
+		{
+			//DRM_DEBUG("Interrupt src_id: %d client_id: %d\n", src_id, client_id);
+		}
 
 		r = src->funcs->process(adev, src, entry);
 		if (r)
diff -ruN a/drivers/gpu/drm/amd/amdgpu/amdgpu_ucode.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_ucode.c
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ucode.c	2022-10-13 07:15:21.293047162 +0200
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ucode.c	2022-10-13 06:49:01.169130328 +0200
@@ -286,6 +286,8 @@
 	case CHIP_KABINI:
 	case CHIP_HAWAII:
 	case CHIP_MULLINS:
+	case CHIP_LIVERPOOL:
+	case CHIP_GLADIUS:
 		return AMDGPU_FW_LOAD_DIRECT;
 #endif
 	case CHIP_TOPAZ:
diff -ruN a/drivers/gpu/drm/amd/amdgpu/atombios_dp.c b/drivers/gpu/drm/amd/amdgpu/atombios_dp.c
--- a/drivers/gpu/drm/amd/amdgpu/atombios_dp.c	2022-10-13 07:15:21.295047210 +0200
+++ b/drivers/gpu/drm/amd/amdgpu/atombios_dp.c	2022-10-13 06:49:01.169130328 +0200
@@ -261,12 +261,19 @@
 		amdgpu_atombios_dp_convert_bpc_to_bpp(amdgpu_connector_get_monitor_bpc(connector));
 	static const unsigned link_rates[3] = { 162000, 270000, 540000 };
 	unsigned max_link_rate = drm_dp_max_link_rate(dpcd);
+	unsigned min_lane_num = 1;
 	unsigned max_lane_num = drm_dp_max_lane_count(dpcd);
 	unsigned lane_num, i, max_pix_clock;
+	struct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);
+	struct drm_device *dev = amdgpu_connector->base.dev;
+	struct amdgpu_device *adev = dev->dev_private;
 
+	/* Liverpool is always connected to an encoder that needs 4 lanes */
+	if (adev->asic_type == CHIP_LIVERPOOL)
+			min_lane_num = 4;
 	if (amdgpu_connector_encoder_get_dp_bridge_encoder_id(connector) ==
 	    ENCODER_OBJECT_ID_NUTMEG) {
-		for (lane_num = 1; lane_num <= max_lane_num; lane_num <<= 1) {
+		for (lane_num = min_lane_num; lane_num <= max_lane_num; lane_num <<= 1) {
 			max_pix_clock = (lane_num * 270000 * 8) / bpp;
 			if (max_pix_clock >= pix_clock) {
 				*dp_lanes = lane_num;
diff -ruN a/drivers/gpu/drm/amd/amdgpu/atombios_encoders.c b/drivers/gpu/drm/amd/amdgpu/atombios_encoders.c
--- a/drivers/gpu/drm/amd/amdgpu/atombios_encoders.c	2022-10-13 07:15:21.295047210 +0200
+++ b/drivers/gpu/drm/amd/amdgpu/atombios_encoders.c	2022-10-13 06:49:01.169130328 +0200
@@ -444,9 +444,11 @@
 	struct drm_connector *connector;
 	struct amdgpu_connector *amdgpu_connector;
 	struct amdgpu_connector_atom_dig *dig_connector;
-
+	struct drm_device *dev = encoder->dev;
+	struct amdgpu_device *adev = dev->dev_private;
 	/* dp bridges are always DP */
-	if (amdgpu_encoder_get_dp_bridge_encoder_id(encoder) != ENCODER_OBJECT_ID_NONE)
+	if (amdgpu_encoder_get_dp_bridge_encoder_id(encoder) != ENCODER_OBJECT_ID_NONE ||
+	adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS)
 		return ATOM_ENCODER_MODE_DP;
 
 	/* DVO is always DVO */
@@ -2152,4 +2154,3 @@
 
 	return dig;
 }
-
diff -ruN a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
--- a/drivers/gpu/drm/amd/amdgpu/cik.c	2022-10-13 07:15:21.295047210 +0200
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c	2022-10-13 06:59:48.277273209 +0200
@@ -747,6 +747,206 @@
 	0xc24d, 0xffffffff, 0x00000000
 };
 
+static const u32 liverpool_golden_common_registers[] =
+{
+		0x31dc, 0xffffffff, 0x00000800, /* SPI_RESOURCE_RESERVE_CU_0 */
+		0x31dd, 0xffffffff, 0x00000800, /* SPI_RESOURCE_RESERVE_CU_1 */
+		0x31e6, 0xffffffff, 0x00ffffbf, /* SPI_RESOURCE_RESERVE_EN_CU_0 */
+		0x31e7, 0xffffffff, 0x00ffffaf, /* SPI_RESOURCE_RESERVE_EN_CU_1 */
+		0x31e8, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_2 */
+		0x31e9, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_3*/
+		0x31ea, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_4 */
+		0x31eb, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_5 */
+		0x31ec, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_6 */
+		0x31ed, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_7 */
+		0x31ee, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_8 */
+		0x31ef, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_9 */
+		0xa0d4, 0xffffffff, 0x2a00161a, /* PA_SC_RASTER_CONFIG */
+		0xa0d5, 0xffffffff, 0x00000000, /* PA_SC_RASTER_CONFIG_1 */
+		0x1401, 0x00002000, 0x00002000, /* GARLIC_FLUSH_CNTL */
+};
+
+static const u32 liverpool_golden_registers[] =
+{
+	0x3108, 0xffffffff, 0xfffffffc, /* RLC_CGTT_MGCG_OVERRIDE */
+	0xc200, 0xffffffff, 0xe0000000, /* GRBM_GFX_INDEX */
+	/* These are all setting OFF_HYSTERESIS = 0x10 */
+	0xf0a8, 0xffffffff, 0x00000100, /* CB_CGTT_SCLK_CTRL */
+	0xf082, 0xffffffff, 0x00000100, /* CGTT_BCI_CLK_CTRL */
+	0xf0b0, 0xffffffff, 0x00000100, /* CGTT_CP_CLK_CTRL */
+	0xf0b2, 0xffffffff, 0x00000100, /* CGTT_CPC_CLK_CTRL */
+	0xf0b1, 0xffffffff, 0x00000100, /* CGTT_CPF_CLK_CTRL */
+	0x1579, 0xffffffff, 0x00600100, /* CGTT_DRM_CLK_CTRL0 */
+	0xf0a0, 0xffffffff, 0x00000100, /* CGTT_GDS_CLK_CTRL */
+	0xf085, 0xffffffff, 0x06000100, /* CGTT_IA_CLK_CTRL */
+	0xf088, 0xffffffff, 0x00000100, /* CGTT_PA_CLK_CTRL */
+	0xf086, 0xffffffff, 0x06000100, /* CGTT_WD_CLK_CTRL */
+	0xf081, 0xffffffff, 0x00000100, /* CGTT_PC_CLK_CTRL */
+	0xf0b8, 0xffffffff, 0x00000100, /* CGTT_RLC_CLK_CTRL */
+	0xf089, 0xffffffff, 0x00000100, /* CGTT_SC_CLK_CTRL */
+	0xf080, 0xffffffff, 0x00000100, /* CGTT_SPI_CLK_CTRL */
+	0xf08c, 0xffffffff, 0x00000100, /* CGTT_SQ_CLK_CTRL */
+	0xf08d, 0xffffffff, 0x00000100, /* CGTT_SQG_CLK_CTRL */
+	0xf094, 0xffffffff, 0x00000100, /* CGTT_SX_CLK_CTRL0 */
+	0xf095, 0xffffffff, 0x00000100, /* CGTT_SX_CLK_CTRL1 */
+	0xf096, 0xffffffff, 0x00000100, /* CGTT_SX_CLK_CTRL2 */
+	0xf097, 0xffffffff, 0x00000100, /* CGTT_SX_CLK_CTRL3 */
+	0xf098, 0xffffffff, 0x00000100, /* CGTT_SX_CLK_CTRL4 */
+	0xf09f, 0xffffffff, 0x00000100, /* CGTT_TCI_CLK_CTRL */
+	0xf09e, 0xffffffff, 0x00000100, /* CGTT_TCP_CLK_CTRL */
+	0xf084, 0xffffffff, 0x06000100, /* CGTT_VGT_CLK_CTRL */
+	0xf0a4, 0xffffffff, 0x00000100, /* DB_CGTT_CLK_CTRL_0 */
+	0xf09d, 0xffffffff, 0x00000100, /* TA_CGTT_CTRL */
+	0xf0ad, 0xffffffff, 0x00000100, /* TCA_CGTT_SCLK_CTRL */
+	0xf0ac, 0xffffffff, 0x00000100, /* TCC_CGTT_SCLK_CTRL */
+	0xf09c, 0xffffffff, 0x00000100, /* TD_CGTT_CTRL */
+	/* */
+	0xc200, 0xffffffff, 0xe0000000, /* GRBM_GFX_INDEX */
+	0xf008, 0xffffffff, 0x00010000, /* CGTS_CU0_SP0_CTRL_REG */
+	0xf009, 0xffffffff, 0x00030002, /* CGTS_CU0_LDS_SQ_CTRL_REG */
+	0xf00a, 0xffffffff, 0x00040007, /* CGTS_CU0_TA_SQC_CTRL_REG */
+	0xf00b, 0xffffffff, 0x00060005, /* CGTS_CU0_SP1_CTRL_REG */
+	0xf00c, 0xffffffff, 0x00090008, /* CGTS_CU0_TD_TCP_CTRL_REG */
+	0xf00d, 0xffffffff, 0x00010000, /* CGTS_CU1_SP0_CTRL_REG */
+	0xf00e, 0xffffffff, 0x00030002, /* CGTS_CU1_LDS_SQ_CTRL_REG */
+	0xf00f, 0xffffffff, 0x00040007, /* CGTS_CU1_TA_CTRL_REG */
+	0xf010, 0xffffffff, 0x00060005, /* CGTS_CU1_SP1_CTRL_REG */
+	0xf011, 0xffffffff, 0x00090008, /* CGTS_CU1_TD_TCP_CTRL_REG */
+	0xf012, 0xffffffff, 0x00010000, /* CGTS_CU2_SP0_CTRL_REG */
+	0xf013, 0xffffffff, 0x00030002, /* CGTS_CU2_LDS_SQ_CTRL_REG */
+	0xf014, 0xffffffff, 0x00040007, /* CGTS_CU2_TA_CTRL_REG */
+	0xf015, 0xffffffff, 0x00060005, /* CGTS_CU2_SP1_CTRL_REG */
+	0xf016, 0xffffffff, 0x00090008, /* CGTS_CU2_TD_TCP_CTRL_REG */
+	0xf017, 0xffffffff, 0x00010000, /* CGTS_CU3_SP0_CTRL_REG */
+	0xf018, 0xffffffff, 0x00030002, /* CGTS_CU3_LDS_SQ_CTRL_REG */
+	0xf019, 0xffffffff, 0x00040007, /* CGTS_CU3_TA_SQC_CTRL_REG */
+	0xf01a, 0xffffffff, 0x00060005, /* CGTS_CU3_SP1_CTRL_REG */
+	0xf01b, 0xffffffff, 0x00090008, /* CGTS_CU3_TD_TCP_CTRL_REG */
+	0xf01c, 0xffffffff, 0x00010000, /* CGTS_CU4_SP0_CTRL_REG */
+	0xf01d, 0xffffffff, 0x00030002, /* CGTS_CU4_LDS_SQ_CTRL_REG */
+	0xf01e, 0xffffffff, 0x00040007, /* CGTS_CU4_TA_CTRL_REG */
+	0xf01f, 0xffffffff, 0x00060005, /* CGTS_CU4_SP1_CTRL_REG */
+	0xf020, 0xffffffff, 0x00090008, /* CGTS_CU4_TD_TCP_CTRL_REG */
+	0xf021, 0xffffffff, 0x00010000, /* CGTS_CU5_SP0_CTRL_REG */
+	0xf022, 0xffffffff, 0x00030002, /* CGTS_CU5_LDS_SQ_CTRL_REG */
+	0xf023, 0xffffffff, 0x00040007, /* CGTS_CU5_TA_CTRL_REG */
+	0xf024, 0xffffffff, 0x00060005, /* CGTS_CU5_SP1_CTRL_REG */
+	0xf025, 0xffffffff, 0x00090008, /* CGTS_CU5_TD_TCP_CTRL_REG */
+	0xf026, 0xffffffff, 0x00010000, /* CGTS_CU6_SP0_CTRL_REG */
+	0xf027, 0xffffffff, 0x00030002, /* CGTS_CU6_LDS_SQ_CTRL_REG */
+	0xf028, 0xffffffff, 0x00040007, /* CGTS_CU6_TA_SQC_CTRL_REG */
+	0xf029, 0xffffffff, 0x00060005, /* CGTS_CU6_SP1_CTRL_REG */
+	0xf02a, 0xffffffff, 0x00090008, /* CGTS_CU6_TD_TCP_CTRL_REG */
+	0xf02b, 0xffffffff, 0x00010000, /* CGTS_CU7_SP0_CTRL_REG */
+	0xf02c, 0xffffffff, 0x00030002, /* CGTS_CU7_LDS_SQ_CTRL_REG */
+	0xf02d, 0xffffffff, 0x00040007, /* CGTS_CU7_TA_SQC_CTRL_REG */
+	0xf02e, 0xffffffff, 0x00060005, /* CGTS_CU7_SP1_CTRL_REG */
+	0xf02f, 0xffffffff, 0x00090008, /* CGTS_CU7_TD_TCP_CTRL_REG */
+	0xf030, 0xffffffff, 0x00010000, /* CGTS_CU8_SP0_CTRL_REG */
+	0xf031, 0xffffffff, 0x00030002, /* CGTS_CU8_LDS_SQ_CTRL_REG */
+	0xf032, 0xffffffff, 0x00040007, /* CGTS_CU8_TA_CTRL_REG */
+	0xf033, 0xffffffff, 0x00060005, /* CGTS_CU8_SP1_CTRL_REG */
+	0xf034, 0xffffffff, 0x00090008, /* CGTS_CU8_TD_TCP_CTRL_REG */
+	0xf035, 0xffffffff, 0x00010000, /* CGTS_CU9_SP0_CTRL_REG */
+	0xf036, 0xffffffff, 0x00030002, /* CGTS_CU9_LDS_SQ_CTRL_REG */
+	0xf037, 0xffffffff, 0x00040007, /* CGTS_CU9_TA_CTRL_REG */
+	0xf038, 0xffffffff, 0x00060005, /* CGTS_CU9_SP1_CTRL_REG */
+	0xf039, 0xffffffff, 0x00090008, /* CGTS_CU9_TD_TCP_CTRL_REG */
+	0xf000, 0xffffffff, 0x96940200, /* CGTS_SM_CTRL_REG */
+	0x21c2, 0xffffffff, 0x00900100, /* CP_RB_WPTR_POLL_CNTL */
+	0x3109, 0xffffffff, 0x0020003f, /* RLC_CGCG_CGLS_CTRL */
+	0x2684, 0x00210000, 0x00018208, /* CB_HW_CONTROL */
+	0xf000, 0xffff1fff, 0x96940200, /* CGTS_SM_CTRL_REG */
+	0xf003, 0xffff0001, 0xff000000, /* CGTS_TCC_DISABLE */
+	0xf004, 0xffff0000, 0xff000000, /* CGTS_USER_TCC_DISABLE */
+	0x1579, 0xff607fff, 0xfc000100, /* CGTT_DRM_CLK_CTRL0 */
+	0xf080, 0xfdfc0fff, 0x00000100, /* CGTT_SPI_CLK_CTRL */
+	0x1bb6, 0x00010000, 0x00010000, /* CRTC_DOUBLE_BUFFER_CONTROL */
+	0x260d, 0xf00fffff, 0x00004400, /* DB_DEBUG2 */
+	0x16ec, 0x000000f0, 0x00000070, /* FBC_DEBUG_COMP */
+	0x263e, 0x73773777, 0x12011003, /* GB_ADDR_CONFIG */
+	0xbd2, 0x73773777, 0x12010001, /* HDP_ADDR_CONFIG */
+	0x2285, 0xf000003f, 0x00000007, /* PA_CL_ENHANCE */
+	0x22fc, 0x00000001, 0x00000001, /* PA_SC_ENHANCE */
+	0x22c9, 0xffffffff, 0x00ffffff, /* PA_SC_FORCE_EOV_MAX_CNTS */
+	0xc281, 0x0000ff0f, 0x00000000, /* PA_SC_LINE_STIPPLE_STATE */
+	0xa293, 0x07ffffff, 0x06000000, /* PA_SC_MODE_CNTL_1 */
+	0x30df, 0xffffffff, 0x00000b00, /* RLC_PG_DELAY_2 */
+	0x136, 0x00000fff, 0x00000100, /* SCLK_CGTT_BLK_CTRL_REG */
+	0xf9e, 0x00000001, 0x00000002, /* SEM_CHICKEN_BITS */
+	0x31da, 0x00000008, 0x00000008, /* SPI_RESET_DEBUG */
+	0x2300, 0x000000ff, 0x00000001, /* SQ_CONFIG */
+	0x2542, 0x00010000, 0x00010000, /* TA_CNTL_AUX */
+	0x2b03, 0xffffffff, 0x76325410, /* TCP_CHAN_STEER_LO */
+	0x31dc, 0xffffffff, 0x00000800, /* SPI_RESOURCE_RESERVE_CU_0 */
+	0x31dd, 0xffffffff, 0x00000800, /* SPI_RESOURCE_RESERVE_CU_1 */
+	0x31e6, 0xffffffff, 0x00ffffbf, /* SPI_RESOURCE_RESERVE_EN_CU_0 */
+	0x31e7, 0xffffffff, 0x00ffffaf, /* SPI_RESOURCE_RESERVE_EN_CU_1  */
+	0x31e8, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_2 */
+	0x31e9, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_3 */
+	0x31ea, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_4 */
+	0x31eb, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_5*/
+	0x31ec, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_6 */
+	0x31ed, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_7 */
+	0x31ee, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_8 */
+	0x31ef, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_9 */
+	0xa0d4, 0xffffffff, 0x2a00161a, /* PA_SC_RASTER_CONFIG */
+	0xa0d5, 0xffffffff, 0x00000000, /* PA_SC_RASTER_CONFIG_1 */
+	0x1401, 0x00002000, 0x00002000, /* GARLIC_FLUSH_CNTL */
+	0x535, 0xffffffff, 0x00000000, /* VM_CONTEXTS_DISABLE */
+};
+
+static const u32 gladius_golden_common_registers[] =
+{
+	mmATC_MISC_CG, 0x000c0fc0, 0x000c0200,
+	mmCB_HW_CONTROL, 0x0001f3cf, 0x00007208,	// 0x2684
+	mmCB_HW_CONTROL_2, 0x0f000000, 0x0f000000,
+	mmCB_HW_CONTROL_3, 0x000001ff, 0x00000040,
+	mmDB_DEBUG2, 0xf00fffff, 0x00000400,
+	mmPA_SC_ENHANCE, 0xffffffff, 0x20000001,
+	mmPA_SC_LINE_STIPPLE_STATE, 0x0000ff0f, 0x00000000,
+	mmPA_SC_RASTER_CONFIG, 0x3f3fffff, 0x2a00161a,
+	mmPA_SC_RASTER_CONFIG_1, 0x0000003f, 0x0000002e,
+	mmRLC_CGCG_CGLS_CTRL, 0x00000003, 0x0020003c, //0x0001003c,
+	0xec9d, 0xffffffff, 0x0001003c,//mmRLC_CGCG_CGLS_CTRL_3D, 0xffffffff, 0x0001003c,
+	mmSQ_CONFIG, 0x07f80000, 0x07180000,
+	mmTA_CNTL_AUX, 0x000f000f, 0x000b0000,
+	mmTCC_CTRL, 0x00100000, 0xf31fff7f,
+	mmTCP_ADDR_CONFIG, 0x000003ff, 0x000000f7,
+	mmTCP_CHAN_STEER_HI, 0xffffffff, 0x00000000,
+	mmVGT_RESET_DEBUG, 0x00000004, 0x00000004,
+	mmDCI_CLK_CNTL, 0x00000080, 0x00000000,
+	mmFBC_DEBUG_COMP, 0x000000f0, 0x00000070,
+	mmFBC_MISC, 0x9f313fff, 0x14302008,
+	mmHDMI_CONTROL, 0x313f031f, 0x00000011,
+};
+
+static const u32 gladius_golden_registers[] =
+{
+	mmGRBM_GFX_INDEX, 0xffffffff, 0xe0000000,
+	mmPA_SC_RASTER_CONFIG, 0xffffffff, 0x2a00161a,
+	mmPA_SC_RASTER_CONFIG_1, 0xffffffff, 0x0000002e,
+	mmGB_ADDR_CONFIG, 0xffffffff, 0x22011003, //0x22011003,
+	mmSPI_RESOURCE_RESERVE_CU_0, 0xffffffff, 0x00000800,
+	mmSPI_RESOURCE_RESERVE_CU_1, 0xffffffff, 0x00000800,
+	mmSPI_RESOURCE_RESERVE_EN_CU_0, 0xffffffff, 0x00FF7FBF,
+	mmSPI_RESOURCE_RESERVE_EN_CU_1, 0xffffffff, 0x00FF7FAF,
+	0x535, 0xffffffff, 0x00000000, /* VM_CONTEXTS_DISABLE */
+
+};
+
+static const u32 gladius_mgcg_cgcg_init[] =
+{
+	0x0000313a, 0xffffffff, 0x00000003,
+	0x00003079, 0xffffffff, 0x00020201,
+	0x00003108, 0xffffffff, 0xfffffffd,
+	0x0000c200, 0xffffffff, 0xe0000000,
+	0x0000311d, 0xffffffff, 0xffffffff,
+	0x0000311e, 0xffffffff, 0xffffffff,
+	0x0000311f, 0xffffffff, 0x004000ff,
+	0x0000313a, 0xffffffff, 0x00000001,
+};
+
 static void cik_init_golden_registers(struct amdgpu_device *adev)
 {
 	/* Some of the registers might be dependent on GRBM_GFX_INDEX */
@@ -823,6 +1023,31 @@
 							hawaii_golden_spm_registers,
 							ARRAY_SIZE(hawaii_golden_spm_registers));
 		break;
+	case CHIP_LIVERPOOL:
+		/*amdgpu_device_program_register_sequence(adev,
+						 liverpool_mgcg_cgcg_init,
+						 ARRAY_SIZE(liverpool_mgcg_cgcg_init));*/
+		amdgpu_device_program_register_sequence(adev,
+						 liverpool_golden_registers,
+						 ARRAY_SIZE(liverpool_golden_registers));
+		amdgpu_device_program_register_sequence(adev,
+						 liverpool_golden_common_registers,
+						 ARRAY_SIZE(liverpool_golden_common_registers));
+		break;
+	case CHIP_GLADIUS:
+		amdgpu_device_program_register_sequence(adev,
+						 gladius_mgcg_cgcg_init,
+						 ARRAY_SIZE(gladius_mgcg_cgcg_init));
+		amdgpu_device_program_register_sequence(adev,
+						 gladius_golden_registers,
+						 ARRAY_SIZE(gladius_golden_registers));
+		amdgpu_device_program_register_sequence(adev,
+						 gladius_golden_common_registers,
+						 ARRAY_SIZE(gladius_golden_common_registers));
+		amdgpu_device_program_register_sequence(adev,
+						 hawaii_golden_spm_registers,
+						 ARRAY_SIZE(hawaii_golden_spm_registers));
+		break;
 	default:
 		break;
 	}
@@ -1888,6 +2113,63 @@
 		} else
 			adev->external_rev_id = adev->rev_id + 0xa1;
 		break;
+		case CHIP_LIVERPOOL:
+			adev->cg_flags =
+				AMD_CG_SUPPORT_GFX_MGCG |
+				AMD_CG_SUPPORT_GFX_MGLS |
+				/*AMD_CG_SUPPORT_GFX_CGCG |*/
+				AMD_CG_SUPPORT_GFX_CGLS |
+				AMD_CG_SUPPORT_GFX_CGTS |
+				AMD_CG_SUPPORT_GFX_CGTS_LS |
+				AMD_CG_SUPPORT_GFX_CP_LS |
+				AMD_CG_SUPPORT_SDMA_MGCG |
+				AMD_CG_SUPPORT_SDMA_LS |
+				AMD_CG_SUPPORT_BIF_LS |
+				AMD_CG_SUPPORT_VCE_MGCG |
+				AMD_CG_SUPPORT_UVD_MGCG |
+				AMD_CG_SUPPORT_HDP_LS |
+				AMD_CG_SUPPORT_HDP_MGCG;
+			adev->pg_flags =
+				/*AMD_PG_SUPPORT_GFX_PG |
+				  AMD_PG_SUPPORT_GFX_SMG | */
+				/*AMD_PG_SUPPORT_UVD | */
+				/*AMD_PG_SUPPORT_VCE |
+				  AMD_PG_SUPPORT_CP |
+				  AMD_PG_SUPPORT_GDS |
+				  AMD_PG_SUPPORT_RLC_SMU_HS |
+				  AMD_PG_SUPPORT_SAMU |*/
+				0;
+			adev->external_rev_id = adev->rev_id + 0x61;
+			break;
+
+		case CHIP_GLADIUS:
+			adev->cg_flags =
+				AMD_CG_SUPPORT_GFX_MGCG |
+				AMD_CG_SUPPORT_GFX_MGLS |
+				AMD_CG_SUPPORT_GFX_CGCG |
+				AMD_CG_SUPPORT_GFX_CGLS |
+				AMD_CG_SUPPORT_GFX_CGTS |
+				AMD_CG_SUPPORT_GFX_CGTS_LS |
+				AMD_CG_SUPPORT_GFX_CP_LS |
+				AMD_CG_SUPPORT_SDMA_MGCG |
+				AMD_CG_SUPPORT_SDMA_LS |
+				AMD_CG_SUPPORT_BIF_LS |
+				AMD_CG_SUPPORT_VCE_MGCG |
+				AMD_CG_SUPPORT_UVD_MGCG |
+				AMD_CG_SUPPORT_HDP_LS |
+				AMD_CG_SUPPORT_HDP_MGCG;
+			adev->pg_flags =
+				/*AMD_PG_SUPPORT_GFX_PG |
+					AMD_PG_SUPPORT_GFX_SMG | */
+				/*AMD_PG_SUPPORT_UVD | */
+				/*AMD_PG_SUPPORT_VCE |
+					AMD_PG_SUPPORT_CP |
+					AMD_PG_SUPPORT_GDS |
+					AMD_PG_SUPPORT_RLC_SMU_HS |
+					AMD_PG_SUPPORT_SAMU |*/
+				0;
+			adev->external_rev_id = adev->rev_id + 0x71;
+			break;
 	default:
 		/* FIXME: not supported yet */
 		return -EINVAL;
@@ -2077,6 +2359,42 @@
 		amdgpu_device_ip_block_add(adev, &uvd_v4_2_ip_block);
 		amdgpu_device_ip_block_add(adev, &vce_v2_0_ip_block);
 		break;
+	case CHIP_LIVERPOOL:
+		amdgpu_device_ip_block_add(adev, &cik_common_ip_block);
+		amdgpu_device_ip_block_add(adev, &gmc_v7_0_ip_block);
+		amdgpu_device_ip_block_add(adev, &cik_ih_ip_block);
+		//amdgpu_device_ip_block_add(adev, &pp_smu_ip_block);
+		if (adev->enable_virtual_display)
+			amdgpu_device_ip_block_add(adev, &dce_virtual_ip_block);
+#if defined(CONFIG_DRM_AMD_DC)
+		else if (amdgpu_device_has_dc_support(adev))
+			amdgpu_device_ip_block_add(adev, &dm_ip_block);
+#endif
+		else
+			amdgpu_device_ip_block_add(adev, &dce_v8_1_ip_block);
+		amdgpu_device_ip_block_add(adev, &gfx_v7_1_ip_block);
+		amdgpu_device_ip_block_add(adev, &cik_sdma_ip_block);
+		/*amdgpu_device_ip_block_add(adev, &uvd_v4_2_ip_block)*/;
+		/*amdgpu_device_ip_block_add(adev, &vce_v2_0_ip_block)*/;
+		break;
+	case CHIP_GLADIUS:
+		amdgpu_device_ip_block_add(adev, &cik_common_ip_block);
+		amdgpu_device_ip_block_add(adev, &gmc_v7_0_ip_block);
+		amdgpu_device_ip_block_add(adev, &cik_ih_ip_block);
+		//amdgpu_device_ip_block_add(adev, &pp_smu_ip_block);
+		if (adev->enable_virtual_display)
+			amdgpu_device_ip_block_add(adev, &dce_virtual_ip_block);
+#if defined(CONFIG_DRM_AMD_DC)
+		else if (amdgpu_device_has_dc_support(adev))
+			amdgpu_device_ip_block_add(adev, &dm_ip_block);
+#endif
+		else
+			amdgpu_device_ip_block_add(adev, &dce_v8_1_ip_block);
+		amdgpu_device_ip_block_add(adev, &gfx_v7_1_ip_block);
+		amdgpu_device_ip_block_add(adev, &cik_sdma_ip_block);
+		/*amdgpu_device_ip_block_add(adev, &uvd_v4_2_ip_block)*/;
+		/*amdgpu_device_ip_block_add(adev, &vce_v2_0_ip_block)*/;
+		break;
 	default:
 		/* FIXME: not supported yet */
 		return -EINVAL;
diff -ruN a/drivers/gpu/drm/amd/amdgpu/cik_sdma.c b/drivers/gpu/drm/amd/amdgpu/cik_sdma.c
--- a/drivers/gpu/drm/amd/amdgpu/cik_sdma.c	2022-10-13 07:15:21.299047307 +0200
+++ b/drivers/gpu/drm/amd/amdgpu/cik_sdma.c	2022-10-13 06:49:01.169130328 +0200
@@ -64,6 +64,10 @@
 MODULE_FIRMWARE("amdgpu/kabini_sdma1.bin");
 MODULE_FIRMWARE("amdgpu/mullins_sdma.bin");
 MODULE_FIRMWARE("amdgpu/mullins_sdma1.bin");
+MODULE_FIRMWARE("amdgpu/liverpool_sdma.bin");
+MODULE_FIRMWARE("amdgpu/liverpool_sdma1.bin");
+MODULE_FIRMWARE("amdgpu/gladius_sdma.bin");
+MODULE_FIRMWARE("amdgpu/gladius_sdma1.bin");
 
 u32 amdgpu_cik_gpu_check_soft_reset(struct amdgpu_device *adev);
 
@@ -127,6 +131,12 @@
 	case CHIP_MULLINS:
 		chip_name = "mullins";
 		break;
+	case CHIP_LIVERPOOL:
+		chip_name = "liverpool";
+		break;
+	case CHIP_GLADIUS:
+		chip_name = "gladius";
+		break;
 	default: BUG();
 	}
 
@@ -633,11 +643,20 @@
 		amdgpu_device_wb_free(adev, index);
 		return r;
 	}
-	amdgpu_ring_write(ring, SDMA_PACKET(SDMA_OPCODE_WRITE, SDMA_WRITE_SUB_OPCODE_LINEAR, 0));
-	amdgpu_ring_write(ring, lower_32_bits(gpu_addr));
-	amdgpu_ring_write(ring, upper_32_bits(gpu_addr));
-	amdgpu_ring_write(ring, 1); /* number of DWs to follow */
-	amdgpu_ring_write(ring, 0xDEADBEEF);
+	/* The SDMA_OPCODE_WRITE opcode is broken in the ring on Liverpool */
+	if (adev->asic_type == CHIP_LIVERPOOL) {
+		amdgpu_ring_write(ring, SDMA_PACKET(SDMA_OPCODE_CONSTANT_FILL, 0, SDMA_CONSTANT_FILL_EXTRA_SIZE(2)));
+		amdgpu_ring_write(ring, lower_32_bits(gpu_addr));
+		amdgpu_ring_write(ring, upper_32_bits(gpu_addr));
+		amdgpu_ring_write(ring, 0xDEADBEEF);
+		amdgpu_ring_write(ring, 4); /* number of bytes */
+	} else {
+		amdgpu_ring_write(ring, SDMA_PACKET(SDMA_OPCODE_WRITE, SDMA_WRITE_SUB_OPCODE_LINEAR, 0));
+		amdgpu_ring_write(ring, lower_32_bits(gpu_addr));
+		amdgpu_ring_write(ring, upper_32_bits(gpu_addr));
+		amdgpu_ring_write(ring, 1); /* number of DWs to follow */
+		amdgpu_ring_write(ring, 0xDEADBEEF);
+	}
 	amdgpu_ring_commit(ring);
 
 	for (i = 0; i < adev->usec_timeout; i++) {
@@ -772,7 +791,6 @@
 				  uint32_t incr)
 {
 	unsigned ndw = count * 2;
-
 	ib->ptr[ib->length_dw++] = SDMA_PACKET(SDMA_OPCODE_WRITE,
 		SDMA_WRITE_SUB_OPCODE_LINEAR, 0);
 	ib->ptr[ib->length_dw++] = lower_32_bits(pe);
diff -ruN a/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c b/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c
--- a/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c	2022-10-13 07:15:21.296047235 +0200
+++ b/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c	2022-10-13 06:49:01.170130353 +0200
@@ -388,6 +388,8 @@
 	switch (adev->asic_type) {
 	case CHIP_BONAIRE:
 	case CHIP_HAWAII:
+	case CHIP_GLADIUS:
+	case CHIP_LIVERPOOL:
 		num_crtc = 6;
 		break;
 	case CHIP_KAVERI:
@@ -1084,7 +1086,9 @@
 	u32 num_heads = 0, lb_size;
 	int i;
 
-	amdgpu_display_update_priority(adev);
+	// FIXME PS4: this stuff is broken
+	return;
+	//amdgpu_display_update_priority(adev);
 
 	for (i = 0; i < adev->mode_info.num_crtc; i++) {
 		if (adev->mode_info.crtcs[i]->base.enabled)
@@ -1378,6 +1382,8 @@
 	else if ((adev->asic_type == CHIP_BONAIRE) ||
 		 (adev->asic_type == CHIP_HAWAII))/* BN/HW: 6 streams, 7 endpoints */
 		adev->mode_info.audio.num_pins = 7;
+		else if (adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS) /* LVP: 3 streams, 3 endpoints (?) */
+			adev->mode_info.audio.num_pins = 3;
 	else
 		adev->mode_info.audio.num_pins = 3;
 
@@ -1392,7 +1398,13 @@
 		adev->mode_info.audio.pin[i].id = i;
 		/* disable audio.  it will be set up later */
 		/* XXX remove once we switch to ip funcs */
-		dce_v8_0_audio_enable(adev, &adev->mode_info.audio.pin[i], false);
+		//dce_v8_0_audio_enable(adev, &adev->mode_info.audio.pin[i], false);
+		/* Liverpool pin 2 is S/PDIF and should always be available */
+		if (adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS)
+			dce_v8_0_audio_enable(adev, &adev->mode_info.audio.pin[i], true);
+		else
+			dce_v8_0_audio_enable(adev, &adev->mode_info.audio.pin[i], false);
+
 	}
 
 	return 0;
@@ -1959,7 +1971,8 @@
 	}
 
 	/* Bytes per pixel may have changed */
-	dce_v8_0_bandwidth_update(adev);
+	if (adev->asic_type != CHIP_LIVERPOOL && adev->asic_type != CHIP_GLADIUS)
+		dce_v8_0_bandwidth_update(adev);
 
 	return 0;
 }
@@ -2573,12 +2586,17 @@
 	drm_mode_crtc_set_gamma_size(&amdgpu_crtc->base, 256);
 	amdgpu_crtc->crtc_id = index;
 	adev->mode_info.crtcs[index] = amdgpu_crtc;
-
-	amdgpu_crtc->max_cursor_width = CIK_CURSOR_WIDTH;
-	amdgpu_crtc->max_cursor_height = CIK_CURSOR_HEIGHT;
-	adev->ddev->mode_config.cursor_width = amdgpu_crtc->max_cursor_width;
-	adev->ddev->mode_config.cursor_height = amdgpu_crtc->max_cursor_height;
-
+	if (adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS) {
+		amdgpu_crtc->max_cursor_width = 64;
+		amdgpu_crtc->max_cursor_height = 64;
+		adev->ddev->mode_config.cursor_width = amdgpu_crtc->max_cursor_width;
+		adev->ddev->mode_config.cursor_height = amdgpu_crtc->max_cursor_height;
+	}
+	else
+	{
+		adev->ddev->mode_config.cursor_width = amdgpu_crtc->max_cursor_width;
+		adev->ddev->mode_config.cursor_height = amdgpu_crtc->max_cursor_height;
+	}
 	amdgpu_crtc->crtc_offset = crtc_offsets[amdgpu_crtc->crtc_id];
 
 	amdgpu_crtc->pll_id = ATOM_PPLL_INVALID;
@@ -2604,10 +2622,12 @@
 	switch (adev->asic_type) {
 	case CHIP_BONAIRE:
 	case CHIP_HAWAII:
+	case CHIP_GLADIUS:
 		adev->mode_info.num_hpd = 6;
 		adev->mode_info.num_dig = 6;
 		break;
 	case CHIP_KAVERI:
+	case CHIP_LIVERPOOL:
 		adev->mode_info.num_hpd = 6;
 		adev->mode_info.num_dig = 7;
 		break;
@@ -2616,6 +2636,7 @@
 		adev->mode_info.num_hpd = 6;
 		adev->mode_info.num_dig = 6; /* ? */
 		break;
+
 	default:
 		/* FIXME: not supported yet */
 		return -EINVAL;
@@ -2728,6 +2749,10 @@
 
 	for (i = 0; i < adev->mode_info.audio.num_pins; i++) {
 		dce_v8_0_audio_enable(adev, &adev->mode_info.audio.pin[i], false);
+		if (adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS)
+			dce_v8_0_audio_enable(adev, &adev->mode_info.audio.pin[i], true);
+		else
+			dce_v8_0_audio_enable(adev, &adev->mode_info.audio.pin[i], false);
 	}
 
 	dce_v8_0_pageflip_interrupt_init(adev);
diff -ruN a/drivers/gpu/drm/amd/amdgpu/dce_virtual.c b/drivers/gpu/drm/amd/amdgpu/dce_virtual.c
--- a/drivers/gpu/drm/amd/amdgpu/dce_virtual.c	2022-10-13 07:15:21.296047235 +0200
+++ b/drivers/gpu/drm/amd/amdgpu/dce_virtual.c	2022-10-13 06:49:01.170130353 +0200
@@ -445,6 +445,8 @@
 	case CHIP_KAVERI:
 	case CHIP_KABINI:
 	case CHIP_MULLINS:
+	case CHIP_LIVERPOOL:
+	case CHIP_GLADIUS:
 		dce_v8_0_disable_dce(adev);
 		break;
 #endif
diff -ruN a/drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c b/drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c
--- a/drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c	2022-10-13 07:15:21.296047235 +0200
+++ b/drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c	2022-10-13 06:49:01.171130379 +0200
@@ -88,6 +88,20 @@
 MODULE_FIRMWARE("amdgpu/mullins_rlc.bin");
 MODULE_FIRMWARE("amdgpu/mullins_mec.bin");
 
+MODULE_FIRMWARE("amdgpu/liverpool_pfp.bin");
+MODULE_FIRMWARE("amdgpu/liverpool_me.bin");
+MODULE_FIRMWARE("amdgpu/liverpool_ce.bin");
+MODULE_FIRMWARE("amdgpu/liverpool_rlc.bin");
+MODULE_FIRMWARE("amdgpu/liverpool_mec.bin");
+MODULE_FIRMWARE("amdgpu/liverpool_mec2.bin");
+
+MODULE_FIRMWARE("amdgpu/gladius_pfp.bin");
+MODULE_FIRMWARE("amdgpu/gladius_me.bin");
+MODULE_FIRMWARE("amdgpu/gladius_ce.bin");
+MODULE_FIRMWARE("amdgpu/gladius_rlc.bin");
+MODULE_FIRMWARE("amdgpu/gladius_mec.bin");
+MODULE_FIRMWARE("amdgpu/gladius_mec2.bin");
+
 static const struct amdgpu_gds_reg_offset amdgpu_gds_reg_offset[] =
 {
 	{mmGDS_VMID0_BASE, mmGDS_VMID0_SIZE, mmGDS_GWS_VMID0, mmGDS_OA_VMID0},
@@ -880,6 +894,420 @@
 	(0x0e00 << 16) | (0x9600 >> 2),
 };
 
+static const u32 liverpool_rlc_save_restore_register_list[] =
+{
+	(0x0600 << 16) | (0x98f4 >> 2),
+	0x00000000,
+	(0x0680 << 16) | (0x98f4 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x98f8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x9900 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xc260 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x90e8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x3c000 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x3c00c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8c1c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x9700 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0x1e00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0x4e00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0x5e00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0x6e00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0x7e00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0x8e00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0x9e00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0xae00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0xbe00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0x89bc >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0x89bc >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8900 >> 2),
+	0x00000000,
+	0x3,
+	(0x0e00 << 16) | (0x9834 >> 2),
+	0x00000000,
+	(0x0000 << 16) | (0x30f00 >> 2),
+	0x00000000,
+	(0x0001 << 16) | (0x30f00 >> 2),
+	0x00000000,
+	(0x0002 << 16) | (0x30f00 >> 2),
+	0x00000000,
+	(0x0003 << 16) | (0x30f00 >> 2),
+	0x00000000,
+	(0x0080 << 16) | (0x30f00 >> 2),
+	0x00000000,
+	(0x0081 << 16) | (0x30f00 >> 2),
+	0x00000000,
+	(0x0082 << 16) | (0x30f00 >> 2),
+	0x00000000,
+	(0x0083 << 16) | (0x30f00 >> 2),
+	0x00000000,
+	(0x0000 << 16) | (0x30f04 >> 2),
+	0x00000000,
+	(0x0001 << 16) | (0x30f04 >> 2),
+	0x00000000,
+	(0x0002 << 16) | (0x30f04 >> 2),
+	0x00000000,
+	(0x0003 << 16) | (0x30f04 >> 2),
+	0x00000000,
+	(0x0080 << 16) | (0x30f04 >> 2),
+	0x00000000,
+	(0x0081 << 16) | (0x30f04 >> 2),
+	0x00000000,
+	(0x0082 << 16) | (0x30f04 >> 2),
+	0x00000000,
+	(0x0083 << 16) | (0x30f04 >> 2),
+	0x00000000,
+	(0x0000 << 16) | (0x30f08 >> 2),
+	0x00000000,
+	(0x0001 << 16) | (0x30f08 >> 2),
+	0x00000000,
+	(0x0002 << 16) | (0x30f08 >> 2),
+	0x00000000,
+	(0x0003 << 16) | (0x30f08 >> 2),
+	0x00000000,
+	(0x0080 << 16) | (0x30f08 >> 2),
+	0x00000000,
+	(0x0081 << 16) | (0x30f08 >> 2),
+	0x00000000,
+	(0x0082 << 16) | (0x30f08 >> 2),
+	0x00000000,
+	(0x0083 << 16) | (0x30f08 >> 2),
+	0x00000000,
+	(0x0000 << 16) | (0x30f0c >> 2),
+	0x00000000,
+	(0x0001 << 16) | (0x30f0c >> 2),
+	0x00000000,
+	(0x0002 << 16) | (0x30f0c >> 2),
+	0x00000000,
+	(0x0003 << 16) | (0x30f0c >> 2),
+	0x00000000,
+	(0x0080 << 16) | (0x30f0c >> 2),
+	0x00000000,
+	(0x0081 << 16) | (0x30f0c >> 2),
+	0x00000000,
+	(0x0082 << 16) | (0x30f0c >> 2),
+	0x00000000,
+	(0x0083 << 16) | (0x30f0c >> 2),
+	0x00000000,
+	(0x0600 << 16) | (0x9b7c >> 2),
+	0x00000000,
+	(0x0680 << 16) | (0x9b7c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8a14 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8a18 >> 2),
+	0x00000000,
+	(0x0600 << 16) | (0x30a00 >> 2),
+	0x00000000,
+	(0x0680 << 16) | (0x30a00 >> 2),
+	0x00000000,
+	(0x1600 << 16) | (0x30a00 >> 2),
+	0x00000000,
+	(0x1680 << 16) | (0x30a00 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8bf0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8bcc >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8b24 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x30a04 >> 2),
+	0x00000000,
+	(0x1e00 << 16) | (0x30a04 >> 2),
+	0x00000000,
+	(0x0600 << 16) | (0x30a10 >> 2),
+	0x00000000,
+	(0x0680 << 16) | (0x30a10 >> 2),
+	0x00000000,
+	(0x1600 << 16) | (0x30a10 >> 2),
+	0x00000000,
+	(0x1680 << 16) | (0x30a10 >> 2),
+	0x00000000,
+	(0x0600 << 16) | (0x30a14 >> 2),
+	0x00000000,
+	(0x0680 << 16) | (0x30a14 >> 2),
+	0x00000000,
+	(0x1600 << 16) | (0x30a14 >> 2),
+	0x00000000,
+	(0x1680 << 16) | (0x30a14 >> 2),
+	0x00000000,
+	(0x0600 << 16) | (0x30a18 >> 2),
+	0x00000000,
+	(0x0680 << 16) | (0x30a18 >> 2),
+	0x00000000,
+	(0x1600 << 16) | (0x30a18 >> 2),
+	0x00000000,
+	(0x1680 << 16) | (0x30a18 >> 2),
+	0x00000000,
+	(0x0600 << 16) | (0x30a2c >> 2),
+	0x00000000,
+	(0x0680 << 16) | (0x30a2c >> 2),
+	0x00000000,
+	(0x1600 << 16) | (0x30a2c >> 2),
+	0x00000000,
+	(0x1680 << 16) | (0x30a2c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xc700 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xc704 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xc708 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xc768 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc770 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc770 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc774 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc774 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc778 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc778 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc77c >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc77c >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc780 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc780 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc784 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc784 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc788 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc788 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc78c >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc78c >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc790 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc790 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc794 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc794 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc798 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc798 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc79c >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc79c >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc7a0 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc7a0 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc7a4 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc7a4 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc7a8 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc7a8 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc7ac >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc7ac >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc7b0 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc7b0 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc7b4 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc7b4 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc7b8 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc7b8 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc7bc >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc7bc >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x9100 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x3c010 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92a8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92ac >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92b0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92b4 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92b8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92bc >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92c0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92c4 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92c8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92cc >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92d0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8c00 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8c04 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8c20 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8c38 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8c3c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xae00 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x9604 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac08 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac0c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac10 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac14 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac58 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac68 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac6c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac70 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac74 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac78 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac7c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac80 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac84 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac88 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac8c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x970c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x9714 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x9718 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x971c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0x1e00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0x4e00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0x5e00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0x6e00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0x7e00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0x8e00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0x9e00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0xae00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0xbe00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xcd10 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xcd14 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88b0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88b4 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88b8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88bc >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0x89c0 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0x89c0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88c4 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x89d0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88d0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88d4 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88d8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8980 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8988 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x89b0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x89b8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x89a0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88c8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88cc >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x89b4 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x3e1fc >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x3c210 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x3c214 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x3c218 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8904 >> 2),
+	0x00000000,
+	1,
+	(0x0e00 << 16) | (0x8c34 >> 2),
+};
 static u32 gfx_v7_0_get_csb_size(struct amdgpu_device *adev);
 static void gfx_v7_0_get_csb_buffer(struct amdgpu_device *adev, volatile u32 *buffer);
 static void gfx_v7_0_init_cp_pg_table(struct amdgpu_device *adev);
@@ -922,6 +1350,12 @@
 	case CHIP_MULLINS:
 		chip_name = "mullins";
 		break;
+	case CHIP_LIVERPOOL:
+		chip_name = "liverpool";
+		break;
+	case CHIP_GLADIUS:
+		chip_name = "gladius";
+		break;
 	default: BUG();
 	}
 
@@ -957,14 +1391,20 @@
 	if (err)
 		goto out;
 
-	if (adev->asic_type == CHIP_KAVERI) {
+	if (adev->asic_type == CHIP_KAVERI || adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS) {
 		snprintf(fw_name, sizeof(fw_name), "amdgpu/%s_mec2.bin", chip_name);
 		err = request_firmware(&adev->gfx.mec2_fw, fw_name, adev->dev);
 		if (err)
+		{
+			pr_err("gfx7: Failed to open firmware \"%s\"\n", fw_name);
 			goto out;
+		}			
 		err = amdgpu_ucode_validate(adev->gfx.mec2_fw);
 		if (err)
-			goto out;
+		{
+			pr_err("gfx7: Failed to validate ucode firmware \"%s\"\n", fw_name);
+ 			goto out;
+		}
 	}
 
 	snprintf(fw_name, sizeof(fw_name), "amdgpu/%s_rlc.bin", chip_name);
@@ -1217,6 +1657,151 @@
 			if (reg_offset != 7)
 				WREG32(mmGB_MACROTILE_MODE0 + reg_offset, macrotile[reg_offset]);
 		break;
+
+case CHIP_LIVERPOOL:
+case CHIP_GLADIUS:
+		tile[0] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
+			   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |
+			   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_64B));
+		tile[1] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
+			   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |
+			   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_128B));
+		tile[2] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
+			   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |
+			   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B));
+		tile[3] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
+			   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |
+			   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_512B));
+		tile[4] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
+			   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |
+			   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			   TILE_SPLIT(split_equal_to_row_size));
+		tile[5] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |
+			   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));
+		tile[6] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |
+			   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |
+			   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B));
+		tile[7] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |
+			   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |
+			   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			   TILE_SPLIT(split_equal_to_row_size));
+		tile[8] = (ARRAY_MODE(ARRAY_LINEAR_ALIGNED) |
+			   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16));
+		tile[9] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |
+			   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			   MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING));
+		tile[10] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
+			    MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |
+			    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+		tile[11] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |
+			    MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |
+			    PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |
+			    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+		tile[12] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |
+			    MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |
+			    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+		tile[13] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |
+			    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING));
+		tile[14] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
+			    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |
+			    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+		tile[16] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |
+			    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |
+			    PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |
+			    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+		tile[17] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |
+			    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |
+			    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+		tile[27] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |
+			    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING));
+		tile[28] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
+			    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |
+			    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+		tile[29] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |
+			    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |
+			    PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |
+			    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+		tile[30] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |
+			    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |
+			    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+			    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+
+		macrotile[0] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |
+				NUM_BANKS(ADDR_SURF_16_BANK));
+		macrotile[1] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |
+				NUM_BANKS(ADDR_SURF_16_BANK));
+		macrotile[2] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |
+				NUM_BANKS(ADDR_SURF_16_BANK));
+		macrotile[3] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |
+				NUM_BANKS(ADDR_SURF_16_BANK));
+		macrotile[4] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |
+				NUM_BANKS(ADDR_SURF_8_BANK));
+		macrotile[5] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |
+				NUM_BANKS(ADDR_SURF_4_BANK));
+		macrotile[6] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |
+				NUM_BANKS(ADDR_SURF_2_BANK));
+		macrotile[8] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_8) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |
+				NUM_BANKS(ADDR_SURF_16_BANK));
+		macrotile[9] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |
+				NUM_BANKS(ADDR_SURF_16_BANK));
+		macrotile[10] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |
+				NUM_BANKS(ADDR_SURF_16_BANK));
+		macrotile[11] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |
+				NUM_BANKS(ADDR_SURF_16_BANK));
+		macrotile[12] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |
+				NUM_BANKS(ADDR_SURF_8_BANK));
+		macrotile[13] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |
+				NUM_BANKS(ADDR_SURF_4_BANK));
+		macrotile[14] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+				BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+				MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |
+				NUM_BANKS(ADDR_SURF_2_BANK));
+
+		for (reg_offset = 0; reg_offset < num_tile_mode_states; reg_offset++)
+			WREG32(mmGB_TILE_MODE0 + reg_offset, tile[reg_offset]);
+		for (reg_offset = 0; reg_offset < num_secondary_tile_mode_states; reg_offset++)
+			if (reg_offset != 7)
+				WREG32(mmGB_MACROTILE_MODE0 + reg_offset, macrotile[reg_offset]);
+		break;
 	case CHIP_HAWAII:
 		tile[0] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
 			   PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |
@@ -1659,6 +2244,17 @@
 		*rconf |= 0x0;
 		*rconf1 |= 0x0;
 		break;
+	case CHIP_LIVERPOOL:
+		*rconf |= RB_MAP_PKR0(2) | RB_MAP_PKR1(2) |
+			  RB_XSEL2(1) | PKR_MAP(2) | PKR_XSEL(1) |
+			  PKR_YSEL(1) | SE_MAP(2) | SE_XSEL(2) |
+			  SE_YSEL(2);
+		*rconf1 |= 0x0;
+		break;
+	case CHIP_GLADIUS:
+		*rconf |= 0x2a00161a;
+		*rconf1 |= 0x0000002e;
+		break;
 	default:
 		DRM_ERROR("unknown asic: 0x%x\n", adev->asic_type);
 		break;
@@ -2186,6 +2782,7 @@
 				DATA_SEL(write64bit ? 2 : 1) | INT_SEL(int_sel ? 2 : 0));
 	amdgpu_ring_write(ring, lower_32_bits(seq));
 	amdgpu_ring_write(ring, upper_32_bits(seq));
+
 }
 
 /**
@@ -2335,7 +2932,6 @@
 	r = amdgpu_ib_schedule(ring, 1, &ib, NULL, &f);
 	if (r)
 		goto err2;
-
 	r = dma_fence_wait_timeout(f, false, timeout);
 	if (r == 0) {
 		DRM_ERROR("amdgpu: IB test timed out\n");
@@ -2347,7 +2943,7 @@
 	}
 	tmp = RREG32(scratch);
 	if (tmp == 0xDEADBEEF) {
-		DRM_DEBUG("ib test on ring %d succeeded\n", ring->idx);
+		DRM_DEBUG("ib test on ring %d succeeded in %d us\n", ring->idx, r);
 		r = 0;
 	} else {
 		DRM_ERROR("amdgpu: ib test failed (scratch(0x%04X)=0x%08X)\n",
@@ -2715,7 +3311,7 @@
 		WREG32(mmCP_MEC_ME1_UCODE_DATA, le32_to_cpup(fw_data++));
 	WREG32(mmCP_MEC_ME1_UCODE_ADDR, 0);
 
-	if (adev->asic_type == CHIP_KAVERI) {
+	if (adev->asic_type == CHIP_KAVERI || adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS ) {
 		const struct gfx_firmware_header_v1_0 *mec2_hdr;
 
 		if (!adev->gfx.mec2_fw)
@@ -3289,6 +3885,14 @@
 			adev->gfx.rlc.reg_list = spectre_rlc_save_restore_register_list;
 			adev->gfx.rlc.reg_list_size =
 				(u32)ARRAY_SIZE(spectre_rlc_save_restore_register_list);
+		} else if (adev->asic_type == CHIP_LIVERPOOL) {
+			adev->gfx.rlc.reg_list = liverpool_rlc_save_restore_register_list;
+			adev->gfx.rlc.reg_list_size =
+				(u32)ARRAY_SIZE(liverpool_rlc_save_restore_register_list);
+		} else if (adev->asic_type == CHIP_GLADIUS) {
+			adev->gfx.rlc.reg_list = liverpool_rlc_save_restore_register_list;
+			adev->gfx.rlc.reg_list_size =
+				(u32)ARRAY_SIZE(liverpool_rlc_save_restore_register_list);
 		} else {
 			adev->gfx.rlc.reg_list = kalindi_rlc_save_restore_register_list;
 			adev->gfx.rlc.reg_list_size =
@@ -3792,7 +4396,7 @@
 	u32 bo_offset = 0;
 	u32 table_offset, table_size;
 
-	if (adev->asic_type == CHIP_KAVERI)
+	if (adev->asic_type == CHIP_KAVERI || adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS)
 		max_me = 5;
 
 	if (adev->gfx.rlc.cp_table_ptr == NULL)
@@ -3916,7 +4520,6 @@
 	u32 tmp;
 
 	WREG32(mmRLC_PG_ALWAYS_ON_CU_MASK, adev->gfx.cu_info.ao_cu_mask);
-
 	tmp = RREG32(mmRLC_MAX_PG_CU);
 	tmp &= ~RLC_MAX_PG_CU__MAX_POWERED_UP_CU_MASK;
 	tmp |= (adev->gfx.cu_info.number << RLC_MAX_PG_CU__MAX_POWERED_UP_CU__SHIFT);
@@ -4095,6 +4698,14 @@
 		buffer[count++] = cpu_to_le32(0x3a00161a);
 		buffer[count++] = cpu_to_le32(0x0000002e);
 		break;
+	case CHIP_LIVERPOOL:
+		buffer[count++] = cpu_to_le32(0x2a00161a);
+		buffer[count++] = cpu_to_le32(0x00000000);
+		break;
+	case CHIP_GLADIUS:
+		buffer[count++] = cpu_to_le32(0x2a00161a);
+		buffer[count++] = cpu_to_le32(0x0000002e);
+		break;
 	default:
 		buffer[count++] = cpu_to_le32(0x00000000);
 		buffer[count++] = cpu_to_le32(0x00000000);
@@ -4379,6 +4990,41 @@
 		adev->gfx.config.sc_earlyz_tile_fifo_size = 0x130;
 		gb_addr_config = BONAIRE_GB_ADDR_CONFIG_GOLDEN;
 		break;
+	case CHIP_LIVERPOOL:
+		adev->gfx.config.max_shader_engines = 2; // Verified
+		adev->gfx.config.max_tile_pipes = 8; // Verified
+		adev->gfx.config.max_cu_per_sh = 9; // Probably OK
+		adev->gfx.config.max_sh_per_se = 1; // Verified
+		adev->gfx.config.max_backends_per_se = 2; // Probably OK?
+		adev->gfx.config.max_texture_channel_caches = 4; // ??
+		adev->gfx.config.max_gprs = 256;
+		adev->gfx.config.max_gs_threads = 32; // ??
+		adev->gfx.config.max_hw_contexts = 8;
+
+		adev->gfx.config.sc_prim_fifo_size_frontend = 0x20;
+		adev->gfx.config.sc_prim_fifo_size_backend = 0x100;
+		adev->gfx.config.sc_hiz_tile_fifo_size = 0x30;
+		adev->gfx.config.sc_earlyz_tile_fifo_size = 0x130;
+		gb_addr_config = HAWAII_GB_ADDR_CONFIG_GOLDEN;
+		break;
+
+	case CHIP_GLADIUS:
+		adev->gfx.config.max_shader_engines = 4; // Verified
+		adev->gfx.config.max_tile_pipes = 8; // Verified
+		adev->gfx.config.max_cu_per_sh = 9; // Probably OK
+		adev->gfx.config.max_sh_per_se = 1; // Verified
+		adev->gfx.config.max_backends_per_se = 2; // Probably OK?
+		adev->gfx.config.max_texture_channel_caches = 8; // ??
+		adev->gfx.config.max_gprs = 256;
+		adev->gfx.config.max_gs_threads = 32; // ??
+		adev->gfx.config.max_hw_contexts = 8;
+
+		adev->gfx.config.sc_prim_fifo_size_frontend = 0x20;
+		adev->gfx.config.sc_prim_fifo_size_backend = 0x100;
+		adev->gfx.config.sc_hiz_tile_fifo_size = 0x30;
+		adev->gfx.config.sc_earlyz_tile_fifo_size = 0x130;
+		gb_addr_config = 0x10000000; //0x22011003; //0x12011003;
+		break;
 	case CHIP_KABINI:
 	case CHIP_MULLINS:
 	default:
@@ -4499,6 +5145,8 @@
 
 	switch (adev->asic_type) {
 	case CHIP_KAVERI:
+	case CHIP_LIVERPOOL:
+	case CHIP_GLADIUS:
 		adev->gfx.mec.num_mec = 2;
 		break;
 	case CHIP_BONAIRE:
@@ -4842,7 +5490,6 @@
 		DRM_DEBUG("invalid me %d\n", me);
 		return;
 	}
-
 	switch (state) {
 	case AMDGPU_IRQ_STATE_DISABLE:
 		mec_int_cntl = RREG32(mec_int_cntl_reg);
@@ -4956,7 +5603,6 @@
 	struct amdgpu_ring *ring;
 	int i;
 
-	DRM_DEBUG("IH: CP EOP\n");
 	me_id = (entry->ring_id & 0x0c) >> 2;
 	pipe_id = (entry->ring_id & 0x03) >> 0;
 	switch (me_id) {
@@ -5198,6 +5844,9 @@
 	else
 		ao_cu_num = adev->gfx.config.max_cu_per_sh;
 
+	if(adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS)
+		ao_cu_num = adev->gfx.config.max_cu_per_sh;
+
 	memset(cu_info, 0, sizeof(*cu_info));
 
 	amdgpu_gfx_parse_disable_cu(disable_masks, 4, 2);
diff -ruN a/drivers/gpu/drm/amd/amdgpu/gmc_v7_0.c b/drivers/gpu/drm/amd/amdgpu/gmc_v7_0.c
--- a/drivers/gpu/drm/amd/amdgpu/gmc_v7_0.c	2022-10-13 07:15:21.297047259 +0200
+++ b/drivers/gpu/drm/amd/amdgpu/gmc_v7_0.c	2022-10-13 07:00:27.800244801 +0200
@@ -146,6 +146,8 @@
 	case CHIP_KAVERI:
 	case CHIP_KABINI:
 	case CHIP_MULLINS:
+	case CHIP_LIVERPOOL:
+	case CHIP_GLADIUS:
 		return 0;
 	default: BUG();
 	}
@@ -396,6 +398,10 @@
 			adev->gmc.gart_size = 256ULL << 20;
 			break;
 #ifdef CONFIG_DRM_AMDGPU_CIK
+		case CHIP_LIVERPOOL:
+		case CHIP_GLADIUS:
+			adev->gmc.gart_size = 512ULL << 20;
+			break;
 		case CHIP_BONAIRE: /* UVD, VCE do not support GPUVM */
 		case CHIP_HAWAII:  /* UVD, VCE do not support GPUVM */
 		case CHIP_KAVERI:  /* UVD, VCE do not support GPUVM */
@@ -671,7 +677,18 @@
 			WREG32(mmVM_CONTEXT8_PAGE_TABLE_BASE_ADDR + i - 8,
 			       adev->gart.table_addr >> 12);
 	}
-
+	if (adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS) {
+		for (i = 2; i < 8; i++) {
+			WREG32(mmVM_CONTEXT0_PAGE_TABLE_START_ADDR + i, 0);
+			WREG32(mmVM_CONTEXT0_PAGE_TABLE_END_ADDR + i,
+			       adev->vm_manager.max_pfn - 1);
+		}
+		for (i = 0; i < 8; i++) {
+			WREG32(mmVM_CONTEXT8_PAGE_TABLE_START_ADDR + i, 0);
+			WREG32(mmVM_CONTEXT8_PAGE_TABLE_END_ADDR + i,
+			       adev->vm_manager.max_pfn - 1);
+		}
+	}
 	/* enable context1-15 */
 	WREG32(mmVM_CONTEXT1_PROTECTION_FAULT_DEFAULT_ADDR,
 	       (u32)(adev->dummy_page_addr >> 12));
diff -ruN a/drivers/iommu/amd_iommu_init.c b/drivers/iommu/amd_iommu_init.c
--- a/drivers/iommu/amd_iommu_init.c	2022-10-13 07:15:21.561053676 +0200
+++ b/drivers/iommu/amd_iommu_init.c	2022-10-13 06:48:56.630014659 +0200
@@ -2350,6 +2350,7 @@
 
 #endif
 }
+#ifndef CONFIG_X86_PS4 // TODO this should detect ps4-ness at runtime
 
 /* SB IOAPIC is always on this device in AMD systems */
 #define IOAPIC_SB_DEVID		((0x00 << 8) | PCI_DEVFN(0x14, 0))
@@ -2402,7 +2403,7 @@
 
 	return ret;
 }
-
+#endif
 static void __init free_dma_resources(void)
 {
 	free_pages((unsigned long)amd_iommu_pd_alloc_bitmap,
@@ -2537,8 +2538,9 @@
 	if (!is_kdump_kernel() || amd_iommu_disabled)
 		disable_iommus();
 
-	if (amd_iommu_irq_remap)
+	/*if (amd_iommu_irq_remap)
 		amd_iommu_irq_remap = check_ioapic_information();
+		*/
 
 	if (amd_iommu_irq_remap) {
 		/*
diff -ruN a/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd.c
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd.c	2022-10-13 07:15:21.299047307 +0200
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_amdkfd.c	2022-10-13 06:49:01.167130277 +0200
@@ -88,6 +88,8 @@
 #ifdef CONFIG_DRM_AMDGPU_CIK
 	case CHIP_KAVERI:
 	case CHIP_HAWAII:
+	case CHIP_GLADIUS:
+	case CHIP_LIVERPOOL:
 		kfd2kgd = amdgpu_amdkfd_gfx_7_get_functions();
 		break;
 #endif
diff -ruN a/drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c	2022-10-13 07:15:21.300047332 +0200
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c	2022-10-13 06:49:01.167130277 +0200
@@ -1492,7 +1492,29 @@
 	.destroy = amdgpu_connector_destroy,
 	.force = amdgpu_connector_dvi_force,
 };
+#ifdef CONFIG_X86_PS4
+int ps4_bridge_get_modes(struct drm_connector *connector);
+int ps4_bridge_mode_valid(struct drm_connector *connector,
+			struct drm_display_mode *mode);
+enum drm_connector_status ps4_bridge_detect(struct drm_connector *connector,
+					  bool force);
 
+
+static const struct drm_connector_helper_funcs amdgpu_ps4_dp_connector_helper_funcs = {
+	.get_modes = ps4_bridge_get_modes,
+	.mode_valid = ps4_bridge_mode_valid,
+	.best_encoder = amdgpu_connector_dvi_encoder,
+};
+
+static const struct drm_connector_funcs amdgpu_ps4_dp_connector_funcs = {
+	.dpms = drm_helper_connector_dpms,
+	.detect = ps4_bridge_detect,
+	.fill_modes = drm_helper_probe_single_connector_modes,
+	//.set_property = amdgpu_connector_set_property,
+	.destroy = amdgpu_connector_destroy,
+	.force = amdgpu_connector_dvi_force,
+};
+#endif
 static const struct drm_connector_funcs amdgpu_connector_edp_funcs = {
 	.dpms = drm_helper_connector_dpms,
 	.detect = amdgpu_connector_dp_detect,
@@ -1522,6 +1544,7 @@
 	uint32_t subpixel_order = SubPixelNone;
 	bool shared_ddc = false;
 	bool is_dp_bridge = false;
+	bool is_ps4_bridge = false;
 	bool has_aux = false;
 
 	if (connector_type == DRM_MODE_CONNECTOR_Unknown)
@@ -1565,7 +1588,16 @@
 	amdgpu_connector = kzalloc(sizeof(struct amdgpu_connector), GFP_KERNEL);
 	if (!amdgpu_connector)
 		return;
-
+	/* Liverpool (PS4) has an DP bridge which needs a special driver, and
+	 * a fake HDMI port that doesn't really exist. */
+	if (adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS) {
+		if (connector_type == DRM_MODE_CONNECTOR_DisplayPort) {
+			connector_type = DRM_MODE_CONNECTOR_HDMIA;
+			is_dp_bridge = true;
+		} else {
+			return;
+		}
+	}
 	connector = &amdgpu_connector->base;
 
 	amdgpu_connector->connector_id = connector_id;
@@ -1616,10 +1648,20 @@
 		case DRM_MODE_CONNECTOR_HDMIA:
 		case DRM_MODE_CONNECTOR_HDMIB:
 		case DRM_MODE_CONNECTOR_DisplayPort:
+		if (is_ps4_bridge) {
 			drm_connector_init(dev, &amdgpu_connector->base,
 					   &amdgpu_connector_dp_funcs, connector_type);
 			drm_connector_helper_add(&amdgpu_connector->base,
 						 &amdgpu_connector_dp_helper_funcs);
+		} else {
+			drm_connector_init(dev, &amdgpu_connector->base,
+						&amdgpu_ps4_dp_connector_funcs, connector_type);
+			drm_connector_helper_add(&amdgpu_connector->base,
+						&amdgpu_ps4_dp_connector_helper_funcs);
+						//&amdgpu_connector_dp_helper_funcs);
+						
+						
+		}
 			drm_object_attach_property(&amdgpu_connector->base.base,
 						      adev->mode_info.underscan_property,
 						      UNDERSCAN_OFF);
diff -ruN a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c	2022-10-13 07:15:21.299047307 +0200
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c	2022-10-13 06:49:01.168130302 +0200
@@ -74,6 +74,8 @@
 	"BONAIRE",
 	"KAVERI",
 	"KABINI",
+	"LIVERPOOL",
+	"GLADIUS",
 	"HAWAII",
 	"MULLINS",
 	"TOPAZ",
@@ -1386,6 +1388,8 @@
 	case CHIP_KAVERI:
 	case CHIP_KABINI:
 	case CHIP_MULLINS:
+	case CHIP_LIVERPOOL:
+	case CHIP_GLADIUS:
 #endif
 	case CHIP_VEGA20:
 	default:
@@ -1510,6 +1514,8 @@
 	case CHIP_KAVERI:
 	case CHIP_KABINI:
 	case CHIP_MULLINS:
+	case CHIP_LIVERPOOL:
+	case CHIP_GLADIUS:
 		if ((adev->asic_type == CHIP_BONAIRE) || (adev->asic_type == CHIP_HAWAII))
 			adev->family = AMDGPU_FAMILY_CI;
 		else
diff -ruN a/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c	2022-10-13 07:15:21.300047332 +0200
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c	2022-10-13 06:49:01.168130302 +0200
@@ -39,6 +39,9 @@
 
 #include "amdgpu_amdkfd.h"
 
+#ifdef CONFIG_X86_PS4
+#include <asm/ps4.h>
+#endif
 /*
  * KMS wrapper.
  * - 3.0.0 - initial driver
@@ -689,6 +692,13 @@
 	{0x1002, 0x985D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|AMD_IS_MOBILITY|AMD_IS_APU},
 	{0x1002, 0x985E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|AMD_IS_MOBILITY|AMD_IS_APU},
 	{0x1002, 0x985F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|AMD_IS_MOBILITY|AMD_IS_APU},
+	/* liverpool */
+	{0x1002, 0x9920, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_LIVERPOOL|AMD_IS_APU},
+	{0x1002, 0x9922, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_LIVERPOOL|AMD_IS_APU},
+	{0x1002, 0x9923, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_LIVERPOOL|AMD_IS_APU},
+	/* gladius */
+	{0x1002, 0x9924, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_GLADIUS|AMD_IS_APU},
+
 #endif
 	/* topaz */
 	{0x1002, 0x6900, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TOPAZ},
@@ -888,6 +898,15 @@
 	if (supports_atomic)
 		kms_driver.driver_features |= DRIVER_ATOMIC;
 
+#ifdef CONFIG_X86_PS4
+	/* On the PS4 (Liverpool graphics) we have a hard dependency on the
+	 * Aeolia driver to set up the HDMI encoder which is connected to it,
+	 * so defer probe until it is ready. This test passes if this isn't
+	 * a PS4 (returns -ENODEV).
+	 */
+	if (apcie_status() == 0)
+		return -EPROBE_DEFER;
+#endif
 	dev = drm_dev_alloc(&kms_driver, &pdev->dev);
 	if (IS_ERR(dev))
 		return PTR_ERR(dev);
diff -ruN a/drivers/gpu/drm/amd/amdgpu/amdgpu_encoders.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_encoders.c
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_encoders.c	2022-10-13 07:15:21.294047186 +0200
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_encoders.c	2022-10-13 06:49:01.168130302 +0200
@@ -31,6 +31,22 @@
 #include "atom.h"
 #include "atombios_encoders.h"
 
+#ifdef CONFIG_X86_PS4
+int ps4_bridge_register(struct drm_connector *connector,
+			     struct drm_encoder *encoder);
+
+static void amdgpu_maybe_add_bridge(struct drm_connector *connector,
+				    struct drm_encoder *encoder)
+{
+	struct drm_device *dev = connector->dev;
+	struct amdgpu_device *adev = dev->dev_private;
+
+	if (adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS) {
+		ps4_bridge_register(connector, encoder);
+	}
+}
+#endif
+
 void
 amdgpu_link_encoder_connector(struct drm_device *dev)
 {
@@ -46,6 +62,9 @@
 		list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
 			amdgpu_encoder = to_amdgpu_encoder(encoder);
 			if (amdgpu_encoder->devices & amdgpu_connector->devices) {
+#ifdef CONFIG_X86_PS4
+				amdgpu_maybe_add_bridge(connector, encoder);
+#endif
 				drm_connector_attach_encoder(connector, encoder);
 				if (amdgpu_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT)) {
 					amdgpu_atombios_encoder_init_backlight(amdgpu_encoder, connector);
